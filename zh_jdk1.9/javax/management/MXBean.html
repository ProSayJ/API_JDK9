<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MXBean (Java SE 9 &amp; JDK 9 )</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <meta name="keywords" content="javax.management.MXBean class"> 
  <link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../script.js"></script> 
  <script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script> 
  <script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> 
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MXBean (Java SE 9 & JDK 9 )";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../";loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../overview-summary.html">概述</a></li> 
       <li><a href="../../java.management-summary.html">Module</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">Class</li> 
       <li><a href="class-use/MXBean.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 9 &amp; JDK 9</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList"> 
       <li><a href="../../javax/management/MBeanTrustPermission.html" title="class in javax.management"><span class="typeNameLink">上一个</span></a></li> 
       <li><a href="../../javax/management/NotCompliantMBeanException.html" title="class in javax.management"><span class="typeNameLink">下一个</span></a></li> 
      </ul> 
      <ul class="navList"> 
       <li><a href="../../index.html?javax/management/MXBean.html" target="_top">框架</a></li> 
       <li><a href="MXBean.html" target="_top">无框架</a></li> 
      </ul> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../allclasses-noframe.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><span>SEARCH:&nbsp;</span> <input type="text" id="search" value=" " disabled> <input type="reset" id="reset" value=" " disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
      <div> 
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>Required&nbsp;|&nbsp;</li> 
        <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li><a href="#annotation.type.element.detail">Element</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">Module</span>&nbsp; 
     <a href="../../java.management-summary.html">java.management</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="../../javax/management/package-summary.html">javax.management</a> 
    </div> 
    <h2 title="Annotation Type MXBean" class="title">Annotation Type MXBean</h2> 
   </div> 
   <div class="contentContainer"> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <br> <pre><a href="../../java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
<a href="../../java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
<a href="../../java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
public @interface <span class="memberNameLabel">MXBean</span></pre> 
       <div class="block"> 
        <p> <span>用于将界面明确标记为MXBean接口或不作为MXBean接口的注释。</span> <span>默认情况下，接口是MXBean接口，如果它是公共的，其名称以<code>MXBean</code> ，如<code>SomethingMXBean</code> 。</span> <span>以下接口是MXBean接口：</span> </p> 
        <pre>  <span>public interface WhatsitMXBean {}

    @MXBean
    public interface Whatsit1Interface {}

    @MXBean(true)
    public interface Whatsit2Interface {}</span> </pre> 
        <p> <span>以下接口不是MXBean接口：</span> </p> 
        <pre>  <span>interface NonPublicInterfaceNotMXBean{}

    public interface Whatsit3Interface{}

    @MXBean(false)
    public interface MisleadingMXBean {}</span> </pre> 
        <h3 id="MXBean-spec"> <span>MXBean规范</span> </h3> 
        <p> <span>MXBean概念提供了一种简单的方法来编写仅引用预定义类型的MBean，由<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>定义的<a href="../../javax/management/openmbean/package-summary.html">类型</a> 。</span> <span>这样，您可以确保您的MBean可以由任何客户端（包括远程客户端）使用，无需客户端访问代表您的MBean类型的<em>模型特定类</em> 。</span> </p> 
        <p> <span>与标准MBean概念相比，这些概念更容易理解。</span> <span>以下是管理对象如何表示为标准MBean以及MXBean：</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre> <pre>
public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <p> <span>你可以看到，这些定义非常相似。</span> <span>唯一的区别是，命名接口的惯例是使用<code><em>Something</em>MXBean</code>作为<code><em>Something</em>MXBean</code> ，而不是<code><em>Something</em>MBean</code>的标准MBean。</span> </p> 
        <p> <span>在这个管理对象中，有一个名为<code>Usage</code>的属性类型为<a href="../../java/lang/management/MemoryUsage.html" title="java.lang.management中的类"><code>MemoryUsage</code></a>的属性。</span> <span>像这样的属性的点是它给出了一组数据项的一致的快照。</span> <span>例如，它可能包括内存池中当前使用的内存量以及内存池的当前最大值。</span> <span>如果这些是单独的项目，通过单独的<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>调用获得，那么我们可以得到在不同时间看不一致的值。</span> <span>我们可能会得到一个<code>used</code>价值，大于<code>max</code>价值。</span> </p> 
        <p> <span>所以我们可以这样定义<code>MemoryUsage</code> ：</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre> <pre>
public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>@ConstructorParameters({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <p> <span>在两种情况下，定义是相同的，除了使用MXBean， <code>MemoryUsage</code>不再需要标记为<code>Serializable</code> （尽管可以）。</span> <span>另一方面，我们添加了一个<a href="../../javax/management/ConstructorParameters.html" title="javax.management中的注释"><code>@ConstructorParameters</code></a>注释来将构造函数参数链接到相应的getter。</span> <span>我们将在下面看到更多的内容。</span> </p> 
        <p> <span><code>MemoryUsage</code>是一个<em>模型特定的类</em> 。</span> <span>使用标准MBean，如果不知道类<code>MemoryUsage</code> ，则MBean服务器的客户端无法访问<code>Usage</code>属性。</span> <span>假设客户端是基于JMX技术的通用控制台。</span> <span>那么控制台必须配置它可能连接到的每个应用程序的特定于模型的类。</span> <span>对于不是用Java语言编写的客户端，问题更加严重。</span> <span>那么可能没有办法告诉客户<code>MemoryUsage</code>是什么样的。</span> </p> 
        <p> <span>这是MXBeans与标准MBeans不同的地方。</span> <span>虽然我们以几乎完全相同的方式定义了管理界面，但MXBean框架<em>将</em>特定于类的类转换为Java平台中的标准类。</span> <span>使用阵列和标准<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包中的<a href="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a>和<a href="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a>类，可以使用标准类来构建任意复杂的数据结构。</span> </p> 
        <p> <span>如果我们比较两个模型的客户端可能是什么样子，这将变得更加清晰</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
          </pre> <pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b><a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a href="../../javax/management/openmbean/CompositeData.html#get-java.lang.String-"><code>get</code></a>("used");</b>
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <p> <span>对于类似<code>String</code>简单类型的属性，代码是一样的。</span> <span>但是对于具有复杂类型的属性，标准MBean代码要求客户端知道特定于型号的类别<code>MemoryUsage</code> ，而MXBean代码不需要非标准类。</span> </p> 
        <p> <span>这里显示的客户端代码对于MXBean客户端来说稍微复杂一些。</span> <span>但是，如果客户端其实是知道该模型，这里的接口是<code>MemoryPoolMXBean</code>和类<code>MemoryUsage</code> ，那么它可以构造一个<em>代理</em> 。</span> <span>当您事先知道模型时，无论您使用的是标准MBean还是MXBean，这是建议与受管对象进行交互的方式：</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
MemoryPool<b>MBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre> <pre>
MemoryPool<b>MXBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMXBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <p> <span>实现MemoryPool对象与标准MBean和MXBean类似。</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre> <pre>
public class MemoryPool
        implements MemoryPool<b>MXBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <p> <span>在这两种情况下，在MBean服务器中注册MBean的工作原理都是相同的：</span> </p> 
        <span> Standard Bean vs. MXBean    Standard MBean MXBean   <pre>
{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre> <pre>
{
    MemoryPool<b>MXBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre>  </span> 
        <table class="plain"> 
        </table> 
        <h2 id="mxbean-def"> <span>MXBean的定义</span> </h2> 
        <p> <span>MXBean是一种MBean。</span> <span>MXBean对象可以直接注册到MBean服务器中，也可以用作<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>的参数，并在MBean服务器中注册MBean。</span> </p> 
        <p> <span>当一个对象在MBean服务器使用注册<code>registerMBean</code>或者<code>createMBean</code>的方法<a href="../../javax/management/MBeanServer.html" title="javax.management中的接口"><code>MBeanServer</code></a>接口，该对象的类的检查，以确定是什么类型的MBean：</span> </p> 
        <ul> 
         <li> <span>如果类实现接口<a href="../../javax/management/DynamicMBean.html" title="javax.management中的接口"><code>DynamicMBean</code>，</a>则MBean是动态MBean。</span> <span>请注意，类<code>StandardMBean</code>实现此接口，因此本例适用于使用类别<code>StandardMBean</code>创建的标准MBean或MXBean。</span> </li> 
         <li> <span>否则，如果类与标准MBean命名约定匹配，则MBean是标准MBean。</span> </li> 
         <li> <span>否则，它可能是一个MXBean。</span> <span>检查由对象实现的一组接口，用于以下接口：</span> 
          <ul> 
           <li> <span>有一个类名<code><em>S</em>MXBean</code>其中<code><em>S</em></code>是任何非空字符串，并没有注释<code>@MXBean(false)</code> ;</span> <span>和/或</span> </li> 
           <li> <span>有注释<code>@MXBean(true)</code>或仅<code>@MXBean</code> 。</span> </li> 
          </ul> <span>如果只有一个这样的接口，或者如果有一个这样的接口是所有其他接口的子接口，则对象是MXBean。</span> <span>该界面是<em>MXBean界面</em> 。</span> <span>在上面的例子中，MXBean接口是<code>MemoryPoolMXBean</code> 。</span> </li> 
         <li> <span>如果不符合这些条件，则MBean无效，尝试注册它将生成<a href="../../javax/management/NotCompliantMBeanException.html" title="javax.management中的类"><code>NotCompliantMBeanException</code></a> 。</span> </li> 
        </ul> 
        <p> <span>在MXBean界面中显示为方法参数或返回类型的每种Java类型都必须使用以下规则进行<em>转换</em> 。</span> <span>另外，参数必须如下所述<em>重构</em> 。</span> </p> 
        <p> <span>尝试构造不符合上述规则的MXBean将产生异常。</span> </p> 
        <h2 id="naming-conv"> <span>命名约定</span> </h2> 
        <p> <span>相同的命名约定应用于MXBean中的方法，如标准MBean中所示：</span> </p> 
        <ol> 
         <li> <span>方法<code><em>T</em> get<em>N</em>()</code> ，其中<code><em>T</em></code>是Java类型（不是<code>void</code> ），并且<code><em>N</em></code>是非空字符串，指定存在称为<code><em>N</em></code>的可读属性。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>该方法<code>final Class getClass()</code>继承自<code>Object</code>查找获取时被忽略。</span> </li> 
         <li> <span>方法<code>boolean is<em>N</em>()</code>指定存在具有Java类型<code>boolean</code>和打开类型<code>SimpleType.Boolean</code>称为<code><em>N</em></code>的可读属性。</span> </li> 
         <li> <span>方法<code>void set<em>N</em>(<em>T</em> x)</code>指定存在称为<code><em>N</em></code>的可写属性。</span> <span>属性的Java类型和Open类型由下面的映射规则确定。</span> <span>（当然这个参数的名称是<code>x</code>是无关紧要的）</span> </li> 
         <li> <span>每个其他方法都指定有一个与该方法名称相同的操作。</span> <span>返回值和每个参数的Java类型和Open类型由以下映射规则确定。</span> </li> 
        </ol> 
        <p> <span><code>get<em>N</em></code>和<code>is<em>N</em></code>的规则共同定义了<em>吸气剂</em>的概念。</span> <span><code>set<em>N</em></code>的规则定义了<em>设置者</em>的概念。</span> </p> 
        <p> <span>这是一个错误，有两个同名的getter，或两个同名的setter。</span> <span>如果有同一个名字的getter和setter，那么两者中的类型<code><em>T</em></code>必须相同。</span> <span>在这种情况下，属性是读/写。</span> <span>如果只有一个getter或只有一个setter，那么该属性是分别只读或只写的。</span> </p> 
        <h2 id="mapping-rules"> <span>键入映射规则</span> </h2> 
        <p> <span>MXBean是一种开放的MBean，由<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包定义。</span> <span>这意味着属性，操作参数和操作返回值的<em>类型</em>都必须使用<em>Open Types</em> （即<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>的四个标准子类）来<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类">描述</a> 。</span> <span>MXBeans通过将Java类型映射到“打开类型”来实现此目的。</span> </p> 
        <p> <span>对于每个Java类型<em>J</em> ，MXBean映射由以下信息描述：</span> </p> 
        <ul> 
         <li> <span>相应的Open Type， <em>opentype（J）</em> 。</span> <span>这是一个<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>的子类的<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类">实例</a> 。</span> </li> 
         <li> <span><em>映射的</em> Java类型， <em>opendata（J）</em> ，对于任何给定的<em>opentype（J）</em>来说都是相同的。</span> <span>这是一个Java类。</span> </li> 
         <li> <span>如何将值从类型<em>J</em>转换为类型<em>opendata（J）</em> 。</span> </li> 
         <li> <span>如何将值从类型<em>opendata（J）</em>转换为类型<em>J</em> （如果可以）。</span> </li> 
        </ul> 
        <p> <span>例如，对于Java类型<code>List&lt;String&gt;</code> ：</span> </p> 
        <ul> 
         <li> <span>开放型<em>，OpenType字体（</em> <code>List&lt;String&gt;</code> <em>），</em>是<a href="../../javax/management/openmbean/ArrayType.html" title="javax.management.openmbean中的类"><code>ArrayType</code></a> <code>(1,</code> <a href="../../javax/management/openmbean/SimpleType.html#STRING"><code>SimpleType.STRING</code></a> <code>)</code> ，代表的1维阵列<code>String</code>秒。</span> </li> 
         <li> <span>映射的Java类型， <code>List&lt;String&gt;</code> <em>（</em> <code>List&lt;String&gt;</code> <em>）</em>是<code>String[]</code> 。</span> </li> 
         <li> <span>A <code>List&lt;String&gt;</code>可以转换为<code>String[]</code>使用<a href="../../java/util/List.html#toArray-T:A-"><code>List.toArray(new String[0])</code></a> 。</span> </li> 
         <li> <span>甲<code>String[]</code>可以被转换为一个<code>List&lt;String&gt;</code>使用<a href="../../java/util/Arrays.html#asList-T...-"><code>Arrays.asList</code></a> 。</span> </li> 
        </ul> 
        <p> <span>如果没有映射规则从<em>J</em>导出<em>opentype（J）</em> ，则<em>J</em>不能是MXBean接口中的方法参数或返回值的类型。</span> </p> 
        <p id="reconstructible-def"> <span>如果有一种方法将<em>opendata（J）</em>转换回<em>J，</em>那么我们说<em>J</em>是可<em>重构的</em> 。</span> <span>MXBean界面中的所有方法参数必须可重构，因为当MXBean框架正在调用方法时，需要将这些参数从<em>opendata（J）</em>转换为<em>J。</em></span> <span>在由<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code></a>生成的代理中，MXBean接口中方法的返回值必须可重构。</span> </p> 
        <p> <span>所有Java类型和开放类型都允许空值，除了不可能的原始Java类型。</span> <span>当从类型<em>J</em>转换为类型<em>opendata（J）</em>或从类型<em>opendata（J）转换</em>为类型<em>J时</em> ，空值映射到空值。</span> </p> 
        <p> <span>下表总结了类型映射规则。</span> </p> 
        <span> Type Mapping Rules    Java type <em>J</em> <em>opentype(J)</em> <em>opendata(J)</em>     <code>int</code>, <code>boolean</code>, etc<br> (the 8 primitive Java types) <code>SimpleType.INTEGER</code>,<br> <code>SimpleType.BOOLEAN</code>, etc <code>Integer</code>, <code>Boolean</code>, etc<br> (the corresponding boxed types)   <code>Integer</code>, <code>ObjectName</code>, etc<br> (the types covered by <a href="../../javax/management/openmbean/SimpleType.html" title="class in javax.management.openmbean"><code>SimpleType</code></a>) the corresponding <code>SimpleType</code> <em>J</em>, the same type   <code>int[]</code> etc<br> (a one-dimensional array with<br> primitive element type) <code>ArrayType.getPrimitiveArrayType(int[].class)</code> etc <em>J</em>, the same type   <em>E</em><code>[]</code><br> (an array with non-primitive element type <em>E</em>; this includes <code>int[][]</code>, where <em>E</em> is <code>int[]</code>) <code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code> <em>opendata(E)</em><code>[]</code>   <code>List&lt;</code><em>E</em><code>&gt;</code><br> <code>Set&lt;</code><em>E</em><code>&gt;</code><br> <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (see below) same as for <em>E</em><code>[]</code> same as for <em>E</em><code>[]</code>   An enumeration <em>E</em><br> (declared in Java as <code>枚举</code><em>E</em> <code>{...}</code>) <code>SimpleType.STRING</code> <code>String</code>   <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br> <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> <a href="../../javax/management/openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a><br> (see below) <a href="../../javax/management/openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a><br> (see below)   An MXBean interface <code>SimpleType.OBJECTNAME</code><br> (see below) <a href="../../javax/management/ObjectName.html" title="class in javax.management"><code>ObjectName</code></a><br> (see below)   Any other type <a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>, if possible<br> (see below) <a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a>  </span> 
        <table class="striped"> 
        </table> 
        <p> <span>以下部分将详细介绍这些规则。</span> </p> 
        <h3> <span>原始类型的映射</span> </h3> 
        <p> <span>8种基本Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ， <code>double</code> ， <code>char</code> ）被映射到相应的盒装类型从<code>java.lang</code> ，即<code>Boolean</code> ， <code>Byte</code>等开放式是相应<code>SimpleType</code> 。</span> <span>因此， <code>long</code> <em>（</em> <code>long</code> <em>）</em>是<code>SimpleType.LONG</code> ， <code>long</code> <em>（</em> <code>long</code> <em>）</em>是<code>java.lang.Long</code> 。</span> </p> 
        <p> <span>原始类型的数组，如<code>long[]</code>可以直接表示为Open Type。</span> <span>因此， <code>long[]</code> <em>（</em> <code>long[]</code> <em>）</em>是<code>ArrayType.getPrimitiveArrayType(long[].class)</code> ，而<code>long[]</code> <em>（</em> <code>long[]</code> <em>）</em>是<code>long[]</code> 。</span> </p> 
        <p> <span>实际上，平滑的<code>int</code>和<code>Integer</code>等之间的区别并不显示，因为JMX API中的操作始终是Java对象而不是基元。</span> <span>然而，差异<em>确实</em>出现在数组中。</span> </p> 
        <h3> <span>收藏图（ <code>List&lt;</code> <em>E</em> <code>&gt;</code>等）</span> </h3> 
        <p> <span>A <code>List&lt;</code> <em>E</em> <code>&gt;</code>或<code>Set&lt;</code> <em>E</em> <code>&gt;</code> （例如<code>List&lt;String&gt;</code>或<code>Set&lt;ObjectName&gt;</code>以与相同元件类型的阵列（例如<code>String[]</code>或<code>ObjectName[]</code>相同的方式被映射。</span> </p> 
        <p> <span>A <code>SortedSet&lt;</code> <em>E</em> <code>&gt;</code>也以与<em>E</em> <code>[]</code>相同的方式进行映射，但如果<em>E</em>是实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>的类或接口，则只能转换。</span> <span>因此， <code>SortedSet&lt;String&gt;</code>或<code>SortedSet&lt;Integer&gt;</code>是可转换的，但不是<code>SortedSet&lt;int[]&gt;</code>或<code>SortedSet&lt;List&lt;String&gt;&gt;</code> 。</span> <span><code>SortedSet</code>实例的转换将失败，如果<code>IllegalArgumentException</code>具有非空值<a href="../../java/util/SortedSet.html#comparator--"><code>comparator()</code>，则将失败</a> 。</span> </p> 
        <p> <span>A <code>List&lt;</code> <em>E</em> <code>&gt;</code>被重建为<code>java.util.ArrayList&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span>a <code>Set&lt;</code> <em>E</em> <code>&gt;</code> as a <code>java.util.HashSet&lt;</code> <em>E</em> <code>&gt;</code> ;</span> <span>a <code>SortedSet&lt;</code> <em>E</em> <code>&gt;</code> as a <code>java.util.TreeSet&lt;</code> <em>E</em> <code>&gt;</code> 。</span> </p> 
        <h3> <span>地图映射（ <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>等）</span> </h3> 
        <p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>或<code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ，例如<code>Map&lt;String,ObjectName&gt;</code> ，具有开放类型<a href="../../javax/management/openmbean/TabularType.html" title="javax.management.openmbean中的类"><code>TabularType</code></a>并被映射到<a href="../../javax/management/openmbean/TabularData.html" title="javax.management.openmbean中的接口"><code>TabularData</code></a> 。</span> <span><code>TabularType</code>有两个项目叫做<code>key</code>和<code>value</code> 。</span> <span><code>key</code>的开放类型为<code>key</code> <em>（K）</em> ， <code>value</code>的开放类型为<code>value</code> <em>（V）</em> 。</span> <span><code>TabularType</code>的指数是单项<code>key</code> 。</span> </p> 
        <p> <span>例如， <code>TabularType</code>的<code>Map&lt;String,ObjectName&gt;</code>可能用这样的代码构建：</span> </p> 
        <pre>  <span>String typeName =
    "java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;";
String[] keyValue =
    new String[] {"key", "value"};
OpenType[] openTypes =
    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
    new TabularType(typeName, typeName, rowType, new String[] {"key"});</span> </pre> 
        <p> <span>该<code>typeName</code>这里被确定<a href="#type-names">type name rules</a>详述如下。</span> </p> 
        <p> <span>A <code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>以相同的方式映射，但如果<em>K</em>是实现<a href="../../java/lang/Comparable.html" title="java.lang中的接口"><code>Comparable</code></a>的类或接口，则只能转换。</span> <span>因此，一个<code>SortedMap&lt;String,int[]&gt;</code>是可转换的，但是一个<code>SortedMap&lt;int[],String&gt;</code>不是。</span> <span>一个<code>SortedMap</code>实例的转换将失败，一个<code>IllegalArgumentException</code>如果它有一个非空的<a href="../../java/util/SortedMap.html#comparator--"><code>comparator()</code></a> 。</span> </p> 
        <p> <span>A <code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>被重建为<code>java.util.HashMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> ;</span> <span>a <code>SortedMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> as a <code>java.util.TreeMap&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code> 。</span> </p> 
        <p> <span><code>TabularData</code>是一个接口。</span> <span>用于表示<code>Map&lt;</code> <em>K</em> ， <em>V</em> <code>&gt;</code>作为开放数据的具体类是<a href="../../javax/management/openmbean/TabularDataSupport.html" title="javax.management.openmbean中的类"><code>TabularDataSupport</code></a> ，或另一个实现<code>TabularData</code>类，序列化为<code>TabularDataSupport</code> 。</span> </p> 
        <h3 id="mxbean-map"> <span>用于MXBean接口的映射</span> </h3> 
        <p> <span>MXBean接口或MXBean接口中引用的类型可以引用另一个MXBean接口<em>J。</em></span> <span>那么<code>SimpleType.OBJECTNAME</code> <em>（J）</em>是<code>SimpleType.OBJECTNAME</code> ， <code>SimpleType.OBJECTNAME</code> <em>（J）</em>是<code>ObjectName</code> 。</span> </p> 
        <p> <span>例如，假设您有两个MXBean接口，如下所示：</span> </p> 
        <pre>  <span>public interface ProductMXBean {
    public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
    public ProductMXBean getProduct();
}</span> </pre> 
        <p> <span>实现<code>ModuleMXBean</code>接口的对象从其<code>getProduct</code>方法返回一个实现<code>ProductMXBean</code>接口的对象。</span> <span><code>ModuleMXBean</code>对象和返回的<code>ProductMXBean</code>对象都必须在同一MBean服务器中注册为MXBean。</span> </p> 
        <p> <span>方法<code>ModuleMXBean.getProduct()</code>定义了一个称为<code>Product</code>的属性。</span> <span>此属性的打开类型为<code>SimpleType.OBJECTNAME</code> ，相应的<code>ObjectName</code>值将是引用的<code>ProductMXBean</code>在MBean服务器中注册的名称。</span> </p> 
        <p> <span>如果您为<code>ModuleMXBean</code>创建MXBean代理，并调用其<code>getProduct()</code>方法，则代理将通过创建另一个MXBean代理将<code>ObjectName</code>映射回<code>ProductMXBean</code> 。</span> <span>更正式地，当一个代理人用<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</code></a>进行映射时，需要将<code>objectNameY</code>映射到<code>interfaceY</code> ，另一个MXBean接口，它与<code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code> 。</span> <span>该实现可能返回以前通过调用具有相同参数的<code>JMX.newMXBeanProxy</code>创建的代理，或者可能会创建一个新的代理。</span> </p> 
        <p> <span>对<code>ModuleMXBean</code>接口进行以下更改说明了反向映射：</span> </p> 
        <pre>  <span>public interface ModuleMXBean {
    public ProductMXBean getProduct();
    public void setProduct(ProductMXBean c);
}</span> </pre> 
        <p> <span>现在<code>setProduct</code>方法的存在意味着<code>Product</code>属性是读/写。</span> <span>如前所述，此属性的值为<code>ObjectName</code> 。</span> <span>当属性设置时， <code>ObjectName</code>必须转换为<code>setProduct</code>方法期望的<code>ProductMXBean</code>对象。</span> <span>该对象将是同一MBean服务器中给定的<code>ObjectName</code>的MXBean代理。</span> </p> 
        <p> <span>如果您为<code>ModuleMXBean</code>创建MXBean代理并调用其<code>setProduct</code>方法，则代理将将其<code>ProductMXBean</code>参数映射到<code>ObjectName</code> 。</span> <span>这只有在参数实际上是另一个代理<code>ProductMXBean</code> ，对于同一个<code>ProductMXBean</code>中的<code>MBeanServerConnection</code> 。</span> <span>该代理可以从另一个代理返回（如<code>ModuleMXBean.getProduct()</code> ，它为<code>ProductMXBean</code>返回一个代理）;</span> <span>或者它可以由<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code></a>创建;</span> <span>或者它可以使用<a href="../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a>创建，其中一个调用处理程序是<a href="../../javax/management/MBeanServerInvocationHandler.html" title="javax.management中的类"><code>MBeanServerInvocationHandler</code></a>或一个子类。</span> </p> 
        <p> <span>如果相同的MXBean在两个不同的<code>ObjectName</code>下注册，那么来自另一个MXBean的MXBean的引用将是不明确的。</span> <span>因此，如果MXBean对象已在MBean服务器中注册，并尝试以另一个名称将其注册到同一个MBean服务器中，则结果为<a href="../../javax/management/InstanceAlreadyExistsException.html" title="javax.management中的类"><code>InstanceAlreadyExistsException</code></a> 。</span> <span>一般不建议在同一个名称下注册同一个MBean对象，特别是因为对于<a href="../../javax/management/NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>的MBean来说，它不能正常工作。</span> </p> 
        <h3 id="composite-map"> <span>其他类型的映射</span> </h3> 
        <p> <span>给定一个与上表中其他规则不匹配的Java类或接口<em>J</em> ，MXBean框架将尝试将其映射到<a href="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean中的类"><code>CompositeType</code></a> ，如下所示。</span> <span>该<code>CompositeType</code>的类型名称由下面的<a href="#type-names">type name rules</a>决定。</span> </p> 
        <p> <span>使用约定<a href="#naming-conv">above</a>检查吸烟者的<a href="#naming-conv">课程</a> 。</span> <span>（Getters必须是公共实例方法。）如果没有getter，或者如果任何getter的类型不可转换，则<em>J</em>不可转换。</span> </p> 
        <p> <span>如果至少有一个吸气剂和每个吸气剂都有可转换型，那么<code>CompositeType</code> <em>（J）</em>是一个<code>CompositeType</code> ，每个吸气剂都有一个项目。</span> <span>如果吸气剂是</span> </p> 
        <blockquote> 
         <span><code><em>T</em> get<em>Name</em>()</code></span> 
        </blockquote> 
        <span>那么<code>CompositeType</code>的项目称为<code>name</code>并且具有类型<code>name</code> <em>（T）</em> 。</span> 
        <span>例如，如果项目是</span> 
        <blockquote> 
         <span><code>String getOwner()</code></span> 
        </blockquote> 
        <span>那么该项目称为<code>owner</code>并具有打开类型<code>SimpleType.STRING</code> 。</span> 
        <span>如果吸气剂是</span> 
        <blockquote> 
         <span><code>boolean is<em>Name</em>()</code></span> 
        </blockquote> 
        <span>那么<code>CompositeType</code>的项目称为<code>name</code> ，并且类型为<code>SimpleType.BOOLEAN</code> 。</span> 
        <p> <span>请注意，第一个字符（或代码点）转换为小写。</span> <span>这遵循Java Beans约定，由于历史原因与标准MBean约定不同。</span> <span>在标准MBean或MXBean接口中，方法<code>getOwner</code>定义了一个称为<code>Owner</code>的属性，而在Java Bean或映射的<code>CompositeType</code> ，方法<code>getOwner</code>定义了一个名为<code>owner</code>的属性或项目。</span> </p> 
        <p> <span>如果两种方法产生相同的项目名称（例如， <code>getOwner</code>和<code>isOwner</code>或<code>getOwner</code>和<code>getowner</code> ），则该类型不可转换。</span> </p> 
        <p> <span>当Open Type为<code>CompositeType</code> ，对应的映射Java类型（ <a href="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean中的接口">opendata</a> <em>（J）</em> ）为<a href="../../javax/management/openmbean/CompositeData.html" title="javax.management.openmbean中的接口"><code>CompositeData</code></a> 。</span> <span>对应于刚刚描述的<code>CompositeType</code>从<em>J</em>实例到<code>CompositeData</code>的映射完成如下。</span> <span>首先，如果<em>J</em>实现接口<a href="../../javax/management/openmbean/CompositeDataView.html" title="javax.management.openmbean中的接口"><code>CompositeDataView</code></a> ，那么该接口的<a href="../../javax/management/openmbean/CompositeDataView.html#toCompositeData-javax.management.openmbean.CompositeType-"><code>toCompositeData</code></a>方法被调用来进行转换。</span> <span>否则，通过为每个项目调用getter并将其转换为相应的Open Data类型来构建<code>CompositeData</code> 。</span> <span>因此，吸气剂如</span> </p> 
        <blockquote> 
         <span><code>List&lt;String&gt; getNames()</code></span> 
        </blockquote> 
        <p> <span>将被映射到名称为“ <code>names</code> ”的项目，并打开类型<code>ArrayType(1, SimpleType.STRING)</code> 。</span> <span>转换为<code>CompositeData</code>将致电<code>getNames()</code> ，并将结果<code>List&lt;String&gt;</code>转换为<code>String[]</code>的项目“ <code>names</code> ”。</span> </p> 
        <p> <span><code>CompositeData</code>是一个接口。</span> <span>用于表示打开数据类型的具体类是<a href="../../javax/management/openmbean/CompositeDataSupport.html" title="javax.management.openmbean中的类"><code>CompositeDataSupport</code></a> ，或另一个实现<code>CompositeData</code>类，序列化为<code>CompositeDataSupport</code> 。</span> </p> 
        <h4> <span>从<code>CompositeData</code>重构Java类型<em>J</em>的<code>CompositeData</code></span> </h4> 
        <p> <span>如果对于Java类型<em>J</em> ， <code>CompositeData</code> <em>（J）</em>是<code>CompositeData</code> ，则可以从<code>CompositeData</code>重构<em>J的</em>一个实例，或者<em>J</em>不可重建。</span> <span>如果<code>CompositeData</code>中的任何项目不可重构，那么<em>J</em>也不是可重构的。</span> </p> 
        <p> <span>对于任何给定的<em>J</em> ，请参考以下规则来确定如何从<code>CompositeData</code>重建<em>J的</em>实例。</span> <span>列表中的第一个适用规则是将被使用的规则。</span> </p> 
        <ol> 
         <li><p> <span>如果<em>J</em>有一个方法</span> <br> <span><code>public static</code> <em>J</em> <code>from(CompositeData cd)</code></span> <br> <span>那么该方法被调用来重建<em>J的</em>一个实例。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>具有至少一个具有<a href="../../javax/management/ConstructorParameters.html" title="javax.management中的注释"><code>@javax.management.ConstructorParameters</code></a>或<code>@java.beans.ConstructoProperties</code>注释的公共构造函数， <a href="../../javax/management/ConstructorParameters.html" title="javax.management中的注释">则将</a> <code>@java.beans.ConstructoProperties</code>其中一个构造函数（不一定总是相同的）来重构<em>J</em>的实例。</span> <span>如果构造既与注释<code>@javax.management.ConstructorParameters</code>和<code>@java.beans.ConstructorProperties</code> ， <code>@javax.management.ConstructorParameters</code>将被使用，并<code>@java.beans.ConstructorProperties</code>将被忽略。</span> <span>每个这样的注释必须列出与构造函数具有参数一样多的字符串;</span> <span>每个字符串必须命名一个对应于<em>J</em>的getter的属性;</span> <span>并且该getter的类型必须与相应的构造函数参数相同。</span> <span>在<code>@ConstructorParameters</code>或<code>@ConstructorProperties</code>注释中没有提及的吸气剂不是错误（这些可能对应于不需要重建对象的信息）。</span> </p><p> <span>通过从<code>CompositeData</code>调用具有适当重建项目的构造函数来重建<em>J的</em>一个实例。</span> <span>被调用的构造函数将根据<code>CompositeData</code>实际存在的项目在运行时确定，因为该<code>CompositeData</code>可能来自较早版本的<em>J</em> ，其中并不是所有的项目都存在。</span> <span>如果其<code>@ConstructorParameters</code>或<code>@ConstructorProperties</code>注释中命名的所有属性作为<code>CompositeData</code>项目存在，则构造函数<em>适用</em> 。</span> <span>如果不适用构造函数，则重建<em>J</em>的尝试失败。</span> </p><p> <span>对于任何可能的属性组合，必须是（a）没有适用的构造函数，或（b）只有一个适用的构造函数，或（c）其中一个适用的构造函数命名属性的正确超集由其他适用的构造函数命名。</span> <span>（换句话说，对于哪个构造函数来说绝对不应该有歧义）。如果这个条件不是真的，那么<em>J</em>不可重构。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>有一个public no-arg构造函数，并且对于类型为<em>T</em>和<em>N的</em> <em>J中的</em>每个getter，都有一个具有相同名称和类型的相应setter，那么<em>J的</em>一个实例使用no-arg构造函数构造，调用者将从<code>CompositeData</code>重建的项目<code>CompositeData</code>恢复值。</span> <span>例如，如果有一个方法</span> <br> <code>public List&lt;String&gt; getNames()</code> <br> <span>那么还必须有一种方法</span> <br> <code>public void setNames(List&lt;String&gt; names)</code> <br> <span>这个规则适用。</span> </p><p> <span>如果<code>CompositeData</code>来自较早版本的<em>J</em> ，某些项目可能不存在。</span> <span>在这种情况下，不会调用相应的设置器。</span> </p></li> 
         <li><p> <span>否则，如果<em>J</em>是没有除getter之外的方法的接口，则使用<a href="../../java/lang/reflect/Proxy.html" title="class java.lang.reflect"><code>Proxy</code></a>构建一个<em>J</em>实例，其中<a href="../../javax/management/openmbean/CompositeDataInvocationHandler.html" title="javax.management.openmbean中的类"><code>CompositeDataInvocationHandler</code></a>由<code>CompositeData</code>进行转换。</span> </p></li> 
         <li><p> <span>否则， <em>J</em>不可重构。</span> </p></li> 
        </ol> 
        <p> <span>当<code>java.beans.ConstructorProperties</code>不可见时（例如当java.desktop模块不可读或运行时映像不包含java.desktop模块时），规则2不适用。</span> <span>当定位不包含<code>java.beans</code>包的运行时，并且编译时和运行时间环境之间存在不匹配的地方，其中<em>J</em>使用公共构造函数和<code>ConstructorProperties</code>注释编译时，则除非另有规则适用，否则<em>J</em>不可重构。</span> </p> 
        <p> <span>以下是一些示例，显示了由<code>int</code>和<code>String</code>组成的类型<code>NamedNumber</code>不同方式。</span> <span>在每种情况下， <code>CompositeType</code>如下所示：</span> </p> 
        <blockquote> 
         <span><pre>
<a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre></span> 
        </blockquote> 
        <ol> 
         <li> <span>静态<code>from</code>方法：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>公共构造函数与<code>@ConstructorParameters</code>注释：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>@ConstructorParameters({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>每个吸气剂的设定者：</span> 
          <blockquote> 
           <span><pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre></span> 
          </blockquote></li> 
         <li> <span>仅与吸气口接口：</span> 
          <blockquote> 
           <span><pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre></span> 
          </blockquote></li> 
        </ol> 
        <p> <span>通常情况下，简单地表示数据集<em>不变的</em>类更好。</span> <span>一个不可变类的实例在构造完成后不能被改变。</span> <span>请注意， <code>CompositeData</code>本身是不可变的。</span> <span>不可变性有很多优点，特别是在线程安全和安全方面。</span> <span>因此，如果可能，通常应避免使用设置器的方法。</span> </p> 
        <h3> <span>递归类型</span> </h3> 
        <p> <span>递归（自引用）类型不能在MXBean接口中使用。</span> <span>这是<a href="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean中的类"><code>CompositeType</code></a>的不变性的<a href="../../javax/management/openmbean/CompositeType.html" title="javax.management.openmbean中的类">结果</a> 。</span> <span>例如，以下类型不能是属性的类型，因为它引用自身：</span> </p> 
        <pre>  <span>public interface <b>Node</b> {
    public String getName();
    public int getPriority();
    public <b>Node</b> getNext();
}</span> </pre> 
        <p> <span>总是可以重写这样的递归类型，所以它们不再是递归的。</span> <span>这样做可能需要引入新的类型。</span> <span>例如：</span> </p> 
        <pre>  <span>public interface <b>NodeList</b> {
    public List&lt;Node&gt; getNodes();
}

public interface Node {
    public String getName();
    public int getPriority();
}</span> </pre> 
        <h3> <span>MXBean的MBeanInfo内容</span> </h3> 
        <p> <span>MXBean是一种Open MBean。</span> <span>但是，出于兼容性原因，其<a href="../../javax/management/MBeanInfo.html" title="javax.management中的类"><code>MBeanInfo</code></a>不是<a href="../../javax/management/openmbean/OpenMBeanInfo.html" title="javax.management.openmbean中的接口"><code>OpenMBeanInfo</code></a> 。</span> <span>特别地，当属性，参数或操作返回值的类型是基本类型（如<code>int</code> ）或<code>void</code> （对于返回类型）时，属性，参数或操作将分别由<a href="../../javax/management/MBeanAttributeInfo.html" title="javax.management中的类"><code>MBeanAttributeInfo</code></a>表示， <a href="../../javax/management/MBeanParameterInfo.html" title="javax.management中的类"><code>MBeanParameterInfo</code></a> ，或<a href="../../javax/management/MBeanOperationInfo.html" title="javax.management中的类"><code>MBeanOperationInfo</code></a>其<code>getType()</code>或<code>getReturnType()</code>返回原始名称（ “ <code>int</code> ”等）。</span> <span>是这样的话，即使上述的映射规则指定<em>opendata</em>映射是包装类型（ <code>Integer</code>等）。</span> </p> 
        <p> <span>对于直接在MBean Server中注册的MXBean， <a href="../../javax/management/MBeanInfo.html#getConstructors--"><code>MBeanInfo.getConstructors()</code></a>返回的公共构造函数数组将包含该MXBean的所有公共构造函数。</span> <span>如果MXBean的类不是公开的，那么它的构造函数也不被认为是公开的。</span> <span>为使用<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>类构造的MXBean返回的列表与标准MBean的方法相同。</span> <span>不管MXBean如何构造，其构造函数参数不受MXBean映射规则的约束，也没有相应的<code>OpenType</code> 。</span> </p> 
        <p> <span>如果MXBean不实现<a href="../../javax/management/NotificationBroadcaster.html" title="javax.management中的接口"><code>NotificationBroadcaster</code></a>接口，那么直接在MBean Server中注册的MXBean的<a href="../../javax/management/MBeanInfo.html#getNotifications--"><code>MBeanInfo.getNotifications()</code></a>返回的通知类型数组将为空。</span> <span>否则，将在MXBean注册时拨打<a href="../../javax/management/NotificationBroadcaster.html#getNotificationInfo--"><code>NotificationBroadcaster.getNotificationInfo()</code></a>的结果。</span> <span>即使这种方法的结果随后变化， <code>MBeanInfo.getNotifications()</code>的结果也不会。</span> <span>为使用<a href="../../javax/management/StandardMBean.html" title="javax.management中的类"><code>StandardMBean</code></a>或<a href="../../javax/management/StandardEmitterMBean.html" title="javax.management中的类"><code>StandardEmitterMBean</code></a>类构造的MXBean返回的列表与标准MBean的方法相同。</span> </p> 
        <p> <span>该<a href="../../javax/management/Descriptor.html" title="javax.management中的接口"><code>Descriptor</code></a>对于所有的<code>MBeanAttributeInfo</code> ， <code>MBeanParameterInfo</code>和<code>MBeanOperationInfo</code>包含在对象<code>MBeanInfo</code>将有一个字段<code>openType</code> ，其值是<a href="../../javax/management/openmbean/OpenType.html" title="javax.management.openmbean中的类"><code>OpenType</code></a>由上述映射规则指定。</span> <span>所以即使<code>getType()</code>是“ <code>int</code> ”， <code>getDescriptor().getField("openType")</code>将是<a href="../../javax/management/openmbean/SimpleType.html#INTEGER"><code>SimpleType.INTEGER</code></a> 。</span> </p> 
        <p> <span>每个这些对象的<code>Descriptor</code>也将有一个字段<code>originalType</code> ，它是一个字符串，表示MXBean界面中出现的Java类型。</span> <span>此字符串的格式在下面的<a href="#type-names">Type Names</a>中进行了描述。</span> </p> 
        <p> <span><code>Descriptor</code>为<code>MBeanInfo</code>将有一个字段<code>mxbean</code>的值是字符串“ <code>true</code> ”。</span> </p> 
        <h3 id="type-names"> <span>键入名称</span> </h3> 
        <p> <span>有时，MXBean中的方法参数或返回值的未映射类型<em>T</em>必须用字符串表示。</span> <span>如果<em>T</em>是非泛型类型，则此字符串是由<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>返回的值。</span> <span>否则它是<em>通用字符串（T）</em>的值，定义如下：</span> </p> 
        <ul> 
         <li> <span>如果<em>T</em>是非泛型非数组类型，则<em>通用</em> <a href="../../java/lang/Class.html#getName--">字符串</a> <em>（T）</em>是由<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>返回的值，例如<code>"int"</code>或<code>"java.lang.String"</code> 。</span> </li> 
         <li> <span>如果<em>T</em>是数组<em>E []</em> ， <em>通用</em> <code>"[]"</code> <em>（T）</em>是<em>通用</em> <code>"[]"</code> <em>（E），</em>后跟<code>"[]"</code> 。</span> <span>例如， <em>通用<code>int[]</code> （ <code>int[]</code> ）</em>是<code>"int[]"</code> ， <em>通用<code>List&lt;String&gt;[][]</code> （ <code>List&lt;String&gt;[][]</code> ）</em>是<code>"java.util.List&lt;java.lang.String&gt;[][]"</code> 。</span> </li> 
         <li> <span>否则， <em>T</em>是一个参数化类型，如<code>List&lt;String&gt;</code>和<em>genericstring（T）</em>由以下内容组成：由<code>Class.getName()</code>返回的参数化类型的全限定名;</span> <span>左角支架（ <code>"&lt;"</code> ）;</span> <span><em>通用字符串（A）</em>其中<em>A</em>是第一个类型的参数;</span> <span>如果有第二个类型参数<em>B，</em>那么<code>", "</code> （一个逗号和一个空格），后跟<em>通用</em> <code>", "</code> <em>（B）</em> ;</span> <span>一个直角括号（ <code>"&gt;"</code> ）。</span> </li> 
        </ul> 
        <p> <span>需要注意的是，如果一个方法返回<code>int[]</code> ，这将是用字符串表示<code>"[I"</code>由归国<code>Class.getName()</code> ，但如果方法返回<code>List&lt;int[]&gt;</code> ，这将由字符串来表示<code>"java.util.List&lt;int[]&gt;"</code> 。</span> </p> 
        <h3> <span>例外</span> </h3> 
        <p> <span>使用<a href="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean中的类"><code>OpenDataException</code></a>表示<em>从</em> Java类型映射<em>到</em> Open类型的<a href="../../javax/management/openmbean/OpenDataException.html" title="javax.management.openmbean中的类">问题</a> 。</span> <span>当分析MXBean接口时，可能会发生这种情况，例如，如果它引用了一个类型，如<a href="../../java/util/Random.html" title="java.util中的类"><code>java.util.Random</code></a> ，没有getter。</span> <span>或者，它可以从转换时当一个实例被转换（返回值从一个MXBean方法或参数的方法在MXBean代理）发生，例如<code>SortedSet&lt;String&gt;</code>到<code>String[]</code>如果<code>SortedSet</code>具有非空<code>Comparator</code> 。</span> </p> 
        <p> <span>使用<a href="../../java/io/InvalidObjectException.html" title="java.io中的类"><code>InvalidObjectException</code>发送</a> <em>从</em>打开类型映射<em>到</em> Java类型的<a href="../../java/io/InvalidObjectException.html" title="java.io中的类">问题</a> 。</span> <span>当分析MXBean接口时，例如，如果在需要可重构类型的上下文中引用了根据上述规则不可<em>重构</em>的类型，则可能会发生这种情况。</span> <span>或者当实例被转换时（MXBean中的方法的参数或MXBean代理中的方法的返回值），例如，如果不存在具有该名称的枚举常量，则可以从字符串到枚举。</span> </p> 
        <p> <span>根据上下文， <code>OpenDataException</code>或<code>InvalidObjectException</code>可能包装在另一个例外，如<a href="../../javax/management/RuntimeMBeanException.html" title="javax.management中的类"><code>RuntimeMBeanException</code></a>或<a href="../../java/lang/reflect/UndeclaredThrowableException.html" title="class java.lang.reflect"><code>UndeclaredThrowableException</code></a> 。</span> <span>对于每一个被抛出的异常，条件<em>C</em>将为真<em>：“e</em>是<code>OpenDataException</code>或<code>InvalidObjectException</code> （根据需要），或<em>C</em>是<em>E</em>的真。 <a href="../../java/lang/Throwable.html#getCause--"><code>getCause()</code></a> ”。</span> </p> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.6 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="annotation.type.optional.element.summary"> 
           <!--   --> </a> <h3>Optional Element Summary</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>Optional Elements</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">Modifier and Type</th> 
             <th class="colSecond" scope="col">Optional Element</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>boolean</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../javax/management/MXBean.html#value--">value</a></span></code></th> 
             <td class="colLast"> 
              <div class="block">
                如果注释的界面是MXBean接口，则为true。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="annotation.type.element.detail"> 
           <!--   --> </a> <h3>Element Detail</h3> <a id="value--"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>value</h4> <pre>boolean&nbsp;value</pre> 
            <div class="block">
              如果注释的界面是MXBean接口，则为true。 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               如果注释的界面是MXBean接口，则为true。 
             </dd> 
            </dl> 
            <dl> 
             <dt>
               Default: 
             </dt> 
             <dd>
               真正 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../overview-summary.html">概述</a></li> 
      <li><a href="../../java.management-summary.html">Module</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">Class</li> 
      <li><a href="class-use/MXBean.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 9 &amp; JDK 9</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList"> 
      <li><a href="../../javax/management/MBeanTrustPermission.html" title="class in javax.management"><span class="typeNameLink">上一个</span></a></li> 
      <li><a href="../../javax/management/NotCompliantMBeanException.html" title="class in javax.management"><span class="typeNameLink">下一个</span></a></li> 
     </ul> 
     <ul class="navList"> 
      <li><a href="../../index.html?javax/management/MXBean.html" target="_top">框架</a></li> 
      <li><a href="MXBean.html" target="_top">无框架</a></li> 
     </ul> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../allclasses-noframe.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>Required&nbsp;|&nbsp;</li> 
       <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li><a href="#annotation.type.element.detail">Element</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase9&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../legal/copyright.html">Copyright</a> © 1993, 2017, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java9speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 9+178 --></small> 
    <div id="juede_adDiv" data-docversion="179" data-translate="google" data-version="1.0.0"> 

     <div id="adDivContent">
      本帮助文档是使用
       <a href="http://translate.google.com/" target="_blank">《谷歌翻译》</a>翻译，请与英文版配合使用
      <div>
       <div></div>
      </div>
     </div>
    </div></p> 
  </footer>  
 </body>
</html>