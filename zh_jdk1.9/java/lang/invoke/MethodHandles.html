<!doctype html>
<!-- NewPage -->
<html lang="en">
 <head> 
  <!-- Generated by javadoc --> 
  <title>MethodHandles (Java SE 9 &amp; JDK 9 )</title> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <meta name="keywords" content="java.lang.invoke.MethodHandles class"> 
  <meta name="keywords" content="lookup()"> 
  <meta name="keywords" content="publicLookup()"> 
  <meta name="keywords" content="privateLookupIn()"> 
  <meta name="keywords" content="reflectAs()"> 
  <meta name="keywords" content="arrayConstructor()"> 
  <meta name="keywords" content="arrayLength()"> 
  <meta name="keywords" content="arrayElementGetter()"> 
  <meta name="keywords" content="arrayElementSetter()"> 
  <meta name="keywords" content="arrayElementVarHandle()"> 
  <meta name="keywords" content="byteArrayViewVarHandle()"> 
  <meta name="keywords" content="byteBufferViewVarHandle()"> 
  <meta name="keywords" content="spreadInvoker()"> 
  <meta name="keywords" content="exactInvoker()"> 
  <meta name="keywords" content="invoker()"> 
  <meta name="keywords" content="varHandleExactInvoker()"> 
  <meta name="keywords" content="varHandleInvoker()"> 
  <meta name="keywords" content="explicitCastArguments()"> 
  <meta name="keywords" content="permuteArguments()"> 
  <meta name="keywords" content="constant()"> 
  <meta name="keywords" content="identity()"> 
  <meta name="keywords" content="zero()"> 
  <meta name="keywords" content="empty()"> 
  <meta name="keywords" content="insertArguments()"> 
  <meta name="keywords" content="dropArguments()"> 
  <meta name="keywords" content="dropArgumentsToMatch()"> 
  <meta name="keywords" content="filterArguments()"> 
  <meta name="keywords" content="collectArguments()"> 
  <meta name="keywords" content="filterReturnValue()"> 
  <meta name="keywords" content="foldArguments()"> 
  <meta name="keywords" content="guardWithTest()"> 
  <meta name="keywords" content="catchException()"> 
  <meta name="keywords" content="throwException()"> 
  <meta name="keywords" content="loop()"> 
  <meta name="keywords" content="whileLoop()"> 
  <meta name="keywords" content="doWhileLoop()"> 
  <meta name="keywords" content="countedLoop()"> 
  <meta name="keywords" content="iteratedLoop()"> 
  <meta name="keywords" content="tryFinally()"> 
  <link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
  <link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style"> 
  <script type="text/javascript" src="../../../script.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script> 
  <script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script> 
  <!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]--> 
  <script type="text/javascript" src="../../../jquery/jquery-1.10.2.js"></script> 
  <script type="text/javascript" src="../../../jquery/jquery-ui.js"></script> 
 </head> 
 <body> 
  <script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandles (Java SE 9 & JDK 9 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";loadScripts(document, 'script');</script> 
  <noscript> 
   <div>
     JavaScript is disabled on your browser. 
   </div> 
  </noscript> 
  <header role="banner"> 
   <nav role="navigation"> 
    <div class="fixedNav"> 
     <!-- ========= START OF TOP NAVBAR ======= --> 
     <div class="topNav"> 
      <a id="navbar.top"> 
       <!--   --> </a> 
      <div class="skipNav"> 
       <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
      </div> 
      <a id="navbar.top.firstrow"> 
       <!--   --> </a> 
      <ul class="navList" title="Navigation"> 
       <li><a href="../../../overview-summary.html">概述</a></li> 
       <li><a href="../../../java.base-summary.html">Module</a></li> 
       <li><a href="package-summary.html">软件包</a></li> 
       <li class="navBarCell1Rev">Class</li> 
       <li><a href="class-use/MethodHandles.html">使用</a></li> 
       <li><a href="package-tree.html">树</a></li> 
       <li><a href="../../../deprecated-list.html">已过时的</a></li> 
       <li><a href="../../../index-files/index-1.html">索引</a></li> 
       <li><a href="../../../help-doc.html">帮助</a></li> 
      </ul> 
      <div class="aboutLanguage"> 
       <div style="margin-top: 14px;"> 
        <strong>Java SE 9 &amp; JDK 9</strong> 
       </div> 
      </div> 
     </div> 
     <div class="subNav"> 
      <ul class="navList"> 
       <li><a href="../../../java/lang/invoke/MethodHandleProxies.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
       <li><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
      </ul> 
      <ul class="navList"> 
       <li><a href="../../../index.html?java/lang/invoke/MethodHandles.html" target="_top">框架</a></li> 
       <li><a href="MethodHandles.html" target="_top">无框架</a></li> 
      </ul> 
      <ul class="navList" id="allclasses_navbar_top"> 
       <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
      </ul> 
      <ul class="navListSearch"> 
       <li><span>SEARCH:&nbsp;</span> <input type="text" id="search" value=" " disabled> <input type="reset" id="reset" value=" " disabled> </li> 
      </ul> 
      <div> 
       <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
       <noscript> 
        <div>
          JavaScript is disabled on your browser. 
        </div> 
       </noscript> 
      </div> 
      <div> 
       <ul class="subNavList"> 
        <li>概要：&nbsp;</li> 
        <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.summary">方法</a></li> 
       </ul> 
       <ul class="subNavList"> 
        <li>详细信息：&nbsp;</li> 
        <li>字段&nbsp;|&nbsp;</li> 
        <li>构造方法&nbsp;|&nbsp;</li> 
        <li><a href="#method.detail">方法</a></li> 
       </ul> 
      </div> 
      <a id="skip.navbar.top"> 
       <!--   --> </a> 
     </div> 
     <!-- ========= END OF TOP NAVBAR ========= --> 
    </div> 
    <div class="navPadding">
      &nbsp; 
    </div> 
    <script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script> 
   </nav> 
  </header> 
  <!-- ======== START OF CLASS DATA ======== --> 
  <main role="main"> 
   <div class="header"> 
    <div class="subTitle"> 
     <span class="moduleLabelInType">Module</span>&nbsp; 
     <a href="../../../java.base-summary.html">java.base</a> 
    </div> 
    <div class="subTitle"> 
     <span class="packageLabelInType">软件包</span>&nbsp; 
     <a href="../../../java/lang/invoke/package-summary.html">java.lang.invoke</a> 
    </div> 
    <h2 title="Class MethodHandles" class="title">Class MethodHandles</h2> 
   </div> 
   <div class="contentContainer"> 
    <ul class="inheritance"> 
     <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
     <li> 
      <ul class="inheritance"> 
       <li>java.lang.invoke.MethodHandles</li> 
      </ul> </li> 
    </ul> 
    <div class="description"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <hr> <br> <pre>public class <span class="typeNameLabel">MethodHandles</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre> 
       <div class="block"> 
        <span>该类仅由静态方法组成，或者返回方法句柄。</span> 
        <span>它们分为几类：</span> 
        <ul> 
         <li> <span>有助于创建方法和字段的方法句柄的查找方法。</span> </li> 
         <li> <span>组合方法，将预先存在的方法句柄组合或转换为新的方法。</span> </li> 
         <li> <span>其他工厂方法来创建方法句柄来模拟其他常见的JVM操作或控制流模式。</span> </li> 
        </ul> 
       </div> 
       <dl> 
        <dt> 
         <span class="simpleTagLabel">从以下版本开始：</span> 
        </dt> 
        <dd>
          1.7 
        </dd> 
       </dl> </li> 
     </ul> 
    </div> 
    <div class="summary"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ======== NESTED CLASS SUMMARY ======== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="nested.class.summary"> 
           <!--   --> </a> <h3>Nested Class Summary</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span>Nested Classes</span> 
            <span class="tabEnd">&nbsp;</span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">Modifier and Type</th> 
             <th class="colSecond" scope="col">Class</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr class="altColor"> 
             <td class="colFirst"><code>static class&nbsp;</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></span></code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <em>查找对象</em>是用于创建方法句柄的工厂，当创建需要访问检查时。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> </li> 
        </ul> 
       </section> 
       <!-- ========== METHOD SUMMARY =========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.summary"> 
           <!--   --> </a> <h3>方法摘要</h3> 
          <table class="memberSummary"> 
           <caption> 
            <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
            <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
           </caption> 
           <tbody> 
            <tr> 
             <th class="colFirst" scope="col">Modifier and Type</th> 
             <th class="colSecond" scope="col">方法</th> 
             <th class="colLast" scope="col">描述</th> 
            </tr> 
            <tr id="i0" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayConstructor-java.lang.Class-">arrayConstructor</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成构造所需类型的数组的方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i1" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementGetter-java.lang.Class-">arrayElementGetter</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生方法句柄，提供对数组元素的读取访问。 
              </div> </td> 
            </tr> 
            <tr id="i2" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementSetter-java.lang.Class-">arrayElementSetter</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成方法句柄，为数组的元素提供写访问权限。 
              </div> </td> 
            </tr> 
            <tr id="i3" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementVarHandle-java.lang.Class-">arrayElementVarHandle</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个VarHandle，可以访问arrayClass类型的数组的 
               <code>arrayClass</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i4" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayLength-java.lang.Class-">arrayLength</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生返回数组长度的方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i5" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#byteArrayViewVarHandle-java.lang.Class-java.nio.ByteOrder-">byteArrayViewVarHandle</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;viewArrayClass, <a href="../../../java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个VarHandle，可以访问 
               <code>byte[]</code>数组的元素，就像它是不同的基元数组类型一样，如 
               <code>int[]</code>或 
               <code>long[]</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i6" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#byteBufferViewVarHandle-java.lang.Class-java.nio.ByteOrder-">byteBufferViewVarHandle</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;viewArrayClass, <a href="../../../java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生VarHandle给予访问的元素 
               <code>ByteBuffer</code>视为好像它是一个不同的基本组件类型到的元件的阵列 
               <code>byte</code> ，如 
               <code>int[]</code>或 
               <code>long[]</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i7" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-">catchException</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过在异常处理程序中运行它来创建适应目标方法句柄的方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i8" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-">collectArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用过滤器（另一种方法句柄）预处理其参数的子序列来适应目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i9" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-">constant</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;value)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成请求的返回类型的方法句柄，每次调用时返回给定的常量值。 
              </div> </td> 
            </tr> 
            <tr id="i10" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">countedLoop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterations, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个运行给定次数迭代的循环。 
              </div> </td> 
            </tr> 
            <tr id="i11" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">countedLoop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;start, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;end, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个计数一系列数字的循环。 
              </div> </td> 
            </tr> 
            <tr id="i12" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#doWhileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">doWhileLoop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从初始化器，身体和谓词构造一个 
               <code>do-while</code>循环。 
              </div> </td> 
            </tr> 
            <tr id="i13" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-">dropArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;...&nbsp;valueTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生的方法处理这将调用一些其他指定的 
               <i>目标</i>方法句柄之前丢弃一些伪参数。 
              </div> </td> 
            </tr> 
            <tr id="i14" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">dropArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&gt;&nbsp;valueTypes)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生的方法处理这将调用一些其他指定的 
               <i>目标</i>方法句柄之前丢弃一些伪参数。 
              </div> </td> 
            </tr> 
            <tr id="i15" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArgumentsToMatch-java.lang.invoke.MethodHandle-int-java.util.List-int-">dropArgumentsToMatch</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;skip, <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&gt;&nbsp;newTypes, int&nbsp;pos)</code></th> 
             <td class="colLast"> 
              <div class="block">
                适应目标方法句柄以匹配给定的参数类型列表。 
              </div> </td> 
            </tr> 
            <tr id="i16" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">empty</a></span>​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个忽略任何参数的请求类型的方法句柄，不执行任何操作，并根据返回类型返回合适的默认值。 
              </div> </td> 
            </tr> 
            <tr id="i17" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-">exactInvoker</a></span>​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用方法句柄</em> ，可以用于调用给定类型的任何方法句柄，如同通过 
               <a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code>一样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i18" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-">explicitCastArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成方法句柄，通过成对参数和返回类型转换将给定方法句柄的类型适配为新类型。 
              </div> </td> 
            </tr> 
            <tr id="i19" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">filterArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预处理其一个或多个参数来适应目标方法句柄，每个参数具有自己的一元过滤器函数，然后使用每个预处理的参数替换为相应过滤器函数的结果来调用目标。 
              </div> </td> 
            </tr> 
            <tr id="i20" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">filterReturnValue</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过使用过滤器（另一种方法句柄）对其返回值（如果有的话）进行后处理来适应目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i21" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-">foldArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预先处理一些参数，从给定的位置开始，然后调用具有预处理结果的目标，将其插入原来的参数序列之前，使其适用于目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i22" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">foldArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</code></th> 
             <td class="colLast"> 
              <div class="block">
                通过预处理一些参数来适应目标方法句柄，然后调用具有预处理结果的目标，插入到原始的参数序列中。 
              </div> </td> 
            </tr> 
            <tr id="i23" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">guardWithTest</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</code></th> 
             <td class="colLast"> 
              <div class="block">
                使用方法句柄来调整目标方法句柄，通过用测试保护它，一个布尔值方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i24" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#identity-java.lang.Class-">identity</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成方法句柄，在调用时返回其唯一参数。 
              </div> </td> 
            </tr> 
            <tr id="i25" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-">insertArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;values)</code></th> 
             <td class="colLast"> 
              <div class="block">
                在方法句柄的调用之前提供一个具有一个或多个 
               <em>绑定参数</em>的目标方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i26" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-">invoker</a></span>​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成一个特殊的 
               <em>调用方法句柄</em> ，可以用来调用与给定类型兼容的任何方法句柄，就像通过 
               <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code>一样</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i27" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#iteratedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">iteratedLoop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterator, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个范围超过由 
               <code>Iterator&lt;T&gt;</code>生成的值的 
               <code>Iterator&lt;T&gt;</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i28" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#lookup--">lookup</a></span>​()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回一个具有完整功能的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a> ，以模拟调用者的所有支持的字节码行为。</span> 
              </div> </td> 
            </tr> 
            <tr id="i29" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">loop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>[]...&nbsp;clauses)</code></th> 
             <td class="colLast"> 
              <div class="block">
                构造一个表示循环的方法句柄，该循环具有在每次迭代时更新和检查的多个循环变量。 
              </div> </td> 
            </tr> 
            <tr id="i30" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-">permuteArguments</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType, int...&nbsp;reorder)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成方法句柄，通过重新排序参数，将方法句柄调整到新类型的调用顺序。 
              </div> </td> 
            </tr> 
            <tr id="i31" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#privateLookupIn-java.lang.Class-java.lang.invoke.MethodHandles.Lookup-">privateLookupIn</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;targetClass, <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup)</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回一个<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code>，</a>具有完整功能，可以模拟目标类上的所有支持的字节码行为，包括<a href="MethodHandles.Lookup.html#privacc">private access</a> 。</span> 
              </div> </td> 
            </tr> 
            <tr id="i32" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--">publicLookup</a></span>​()</code></th> 
             <td class="colLast"> 
              <div class="block"> 
               <span>返回值得信赖的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a> 。</span> 
              </div> </td> 
            </tr> 
            <tr id="i33" class="rowColor"> 
             <td class="colFirst"><code>static &lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;<br>T</code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-">reflectAs</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;T&gt;&nbsp;expected, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code></th> 
             <td class="colLast"> 
              <div class="block">
                执行一个未经检查的“裂缝”的 
               <a href="MethodHandleInfo.html#directmh">direct method handle</a> 。 
              </div> </td> 
            </tr> 
            <tr id="i34" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#spreadInvoker-java.lang.invoke.MethodType-int-">spreadInvoker</a></span>​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type, int&nbsp;leadingArgCount)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个方法句柄，它将调用给定的 
               <code>type</code>任何方法句柄，给定数量的尾随参数被单个尾随的 
               <code>Object[]</code>数组替换。 
              </div> </td> 
            </tr> 
            <tr id="i35" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-">throwException</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;returnType, <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生方法句柄，将抛出给定的异常 
               <code>exType</code> 。 
              </div> </td> 
            </tr> 
            <tr id="i36" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#tryFinally-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">tryFinally</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;cleanup)</code></th> 
             <td class="colLast"> 
              <div class="block">
                创建一个方法句柄，通过将其包装在一个 
               <code>try-finally</code>块中来适应 
               <code>target</code>方法句柄。 
              </div> </td> 
            </tr> 
            <tr id="i37" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#varHandleExactInvoker-java.lang.invoke.VarHandle.AccessMode-java.lang.invoke.MethodType-">varHandleExactInvoker</a></span>​(<a href="../../../java/lang/invoke/VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个特殊的 
               <em>调用者方法句柄</em> ，可以用于在任何与其给定类型相关联的访问模式类型的VarHandle上调用签名多态访问模式方法。 
              </div> </td> 
            </tr> 
            <tr id="i38" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#varHandleInvoker-java.lang.invoke.VarHandle.AccessMode-java.lang.invoke.MethodType-">varHandleInvoker</a></span>​(<a href="../../../java/lang/invoke/VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                产生一个特殊的 
               <em>调用者方法句柄</em> ，可以用于在任何与其给定类型相关联的访问模式类型的VarHandle上调用签名多态访问模式方法。 
              </div> </td> 
            </tr> 
            <tr id="i39" class="rowColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#whileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">whileLoop</a></span>​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</code></th> 
             <td class="colLast"> 
              <div class="block">
                从初始化器，身体和谓词构造一个 
               <code>while</code>循环。 
              </div> </td> 
            </tr> 
            <tr id="i40" class="altColor"> 
             <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
             <th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#zero-java.lang.Class-">zero</a></span>​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type)</code></th> 
             <td class="colLast"> 
              <div class="block">
                生成请求的返回类型的常量方法句柄，每次调用时返回该类型的默认值。 
              </div> </td> 
            </tr> 
           </tbody> 
          </table> 
          <ul class="blockList"> 
           <li class="blockList"><a id="methods.inherited.from.class.java.lang.Object"> 
             <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
    <div class="details"> 
     <ul class="blockList"> 
      <li class="blockList"> 
       <!-- ============ METHOD DETAIL ========== --> 
       <section role="region"> 
        <ul class="blockList"> 
         <li class="blockList"><a id="method.detail"> 
           <!--   --> </a> <h3>方法详细信息</h3> <a id="lookup--"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>lookup</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup​()</pre> 
            <div class="block"> 
             <span>返回一个<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code>，</a>具有完整的功能，可以模拟调用者的所有支持的字节码行为。</span> 
             <span>这些功能包括来电者的<a href="MethodHandles.Lookup.html#privacc">private access</a> 。</span> 
             <span>查找对象上的工厂方法可以为调用者通过字节码（包括受保护和私有字段和方法）访问的任何成员创建<a href="MethodHandleInfo.html#directmh">direct method handles</a> 。</span> 
             <span>该查找对象是可以被委托给可信代理的<em>能力</em> 。</span> 
             <span>不要将其存储在不受信任的代码可以访问的位置。</span> 
             <p> <span>这种方法是调用者敏感的，这意味着它可能会向不同的呼叫者返回不同的值。</span> </p> 
             <p> <span>对于任何给定的调用者类别<code>C</code> ，此调用返回的查找对象具有与JVM提供的任何查找对象相同的功能，即在同一调用方类别<code>C</code>执行的<a href="package-summary.html#indyinsn">invokedynamic instruction</a>的引导方法。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个用于此方法的调用者的查找对象，具有私有访问权限 
             </dd> 
            </dl> </li> 
          </ul> <a id="publicLookup--"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>publicLookup</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;publicLookup​()</pre> 
            <div class="block"> 
             <span>返回值得信赖的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code></a> 。</span> 
             <span>查找具有<code>PUBLIC</code>和<code>UNCONDITIONAL</code>模式。</span> 
             <span>它只能用于在无条件导出的包中为公共类的公共成员创建方法句柄。</span> 
             <p> <span>作为纯粹的约定，这个查找对象的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass">lookup class</a>将是<a href="../../../java/lang/Object.html" title="java.lang中的类"><code>Object</code></a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>Object的使用是常规的，并且由于查找模式有限，所以没有向Object，其包或其模块的内部提供特殊访问。</span> 
              <span>因此，该查找对象的查找上下文将是引导类加载器，这意味着它无法找到用户类。</span> 
              <p style="font-size:smaller;"> <span><em>讨论：</em>查找类可以使用<code>C</code>表达式更改为任何其他类<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">C</a> 。</span> <span>但是可以通过更改类加载器来更改查找上下文。</span> <span>公共查找对象总是受到<a href="MethodHandles.Lookup.html#secmgr">security manager checks的约束</a> 。</span> <span>另外，它不能访问<a href="MethodHandles.Lookup.html#callsens">caller sensitive methods</a> 。</span> </p> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个可信赖的查找对象 
             </dd> 
            </dl> </li> 
          </ul> <a id="privateLookupIn-java.lang.Class-java.lang.invoke.MethodHandles.Lookup-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>privateLookupIn</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;privateLookupIn​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;targetClass,
                                                   <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup)
                                            throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
            <div class="block"> 
             <span>返回一个<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class java.lang.invoke"><code>lookup object</code>，</a>具有完整功能，可以在目标类上模拟所有支持的字节码行为，包括<a href="MethodHandles.Lookup.html#privacc">private access</a> 。</span> 
             <span>此方法检查指定为<code>Lookup</code>对象的调用者是否允许对目标类进行<em>深层反射</em> 。</span> 
             <span>如果<code>m1</code>是包含模块<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass--"><code>lookup class</code></a> ，和<code>m2</code>是包含目标类的模块，则该检查可确保</span> 
             <ul> 
              <li> <span><code>m1</code> <a href="../../../java/lang/Module.html#canRead-java.lang.Module-"><code>reads</code></a> <code>m2</code> 。</span> </li> 
              <li> <span><code>m2</code> <a href="../../../java/lang/Module.html#isOpen-java.lang.String-java.lang.Module-"><code>opens</code></a>包含目标类的包至少<code>m1</code> 。</span> </li> 
              <li> <span>查找具有<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#MODULE"><code>MODULE</code></a>查找模式。</span> </li> 
             </ul> 
             <p> <span>如果有一个安全管理器，它的<code>checkPermission</code>方法被调用来检查<code>ReflectPermission("suppressAccessChecks")</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span><code>MODULE</code>查找模式用于验证查找对象是由调用者模块中的代码创建的（或从最初由调用者创建的查找对象派生）。</span> 
              <span>具有<code>MODULE</code>查找模式的查找对象可以与受信任方共享，而不会给予呼叫者<code>PRIVATE</code>和<code>PACKAGE</code>访问。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>targetClass</code> - 目标类 
             </dd> 
             <dd> 
              <code>lookup</code> - 调用者查找对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               目标类的查找对象，具有私有访问权限 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>targetClass</code>是primitve类型或数组类 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>targetClass</code>或 
              <code>caller</code>是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code> - 如果以上指定的访问检查失败 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果安全管理员否认 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#dropLookupMode-int-"><code>MethodHandles.Lookup.dropLookupMode(int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>reflectAs</h4> <pre>public static&nbsp;&lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;&nbsp;T&nbsp;reflectAs​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;T&gt;&nbsp;expected,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</pre> 
            <div class="block"> 
             <span>执行一个未经检查的“裂纹”的<a href="MethodHandleInfo.html#directmh">direct method handle</a> 。</span> 
             <span>结果就好像用户已经获得了足够能够破解目标方法句柄的查找对象，目标上称为<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-"><code>Lookup.revealDirect</code></a> ，以获取其符号引用，然后称为<a href="../../../java/lang/invoke/MethodHandleInfo.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandles.Lookup-"><code>MethodHandleInfo.reflectAs</code></a>来解析对成员的符号引用。</span> 
             <p> <span>如果有安全管理员，它的<code>checkPermission</code>方法被调用了一个<code>ReflectPermission("suppressAccessChecks")</code>权限。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数类型</span> 
             </dt> 
             <dd> 
              <span><code>T</code> - 所需类型的结果， <a href="../../../java/lang/reflect/Member.html" title="java.lang.reflect中的接口"><code>Member</code></a>或子类型</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 一种直接的方法手柄来破解符号参考组件 
             </dd> 
             <dd> 
              <code>expected</code> - 表示所需结果类型 
              <code>T</code>的类对象 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               对方法，构造函数或字段对象的引用 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> - 如果呼叫者没有权限调用 
              <code>setAccessible</code> 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果目标不是直接方法句柄 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果成员不是预期类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               1.8 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayConstructor-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayConstructor</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayConstructor​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)
                                     throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成构造所需类型的数组的方法句柄。</span> 
             <span>方法句柄的返回类型将是数组类型。</span> 
             <span>其唯一参数的类型为<code>int</code> ，它指定数组的大小。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个可以创建给定类型的数组的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>arrayClass</code>不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/reflect/Array.html#newInstance-java.lang.Class-int-"><code>Array.newInstance(Class, int)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayLength-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayLength</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayLength​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)
                                throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生返回数组长度的方法句柄。</span> 
             <span>方法句柄的类型将具有<code>int</code>作为返回类型，其唯一的参数将是数组类型。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以检索给定数组类型的数组的长度 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数是 
              <code>null</code> 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementGetter-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementGetter</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementGetter​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生方法句柄，提供对数组元素的读取访问。</span> 
             <span>方法句柄的类型将具有数组的元素类型的返回类型。</span> 
             <span>它的第一个参数将是数组类型，第二个参数将是<code>int</code> 。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，可以从给定的数组类型加载值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为null 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementSetter-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementSetter</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementSetter​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>生成方法句柄，为数组的元素提供写访问权限。</span> 
             <span>方法句柄的类型将具有void返回类型。</span> 
             <span>它的最后一个参数将是数组的元素类型。</span> 
             <span>第一个和第二个参数将是数组类型和int。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 数组的类 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个可以将值存储到数组类型中的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
            </dl> </li> 
          </ul> <a id="arrayElementVarHandle-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>arrayElementVarHandle</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;arrayElementVarHandle​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生一个VarHandle，可以访问arrayClass类型的数组的<code>arrayClass</code> 。</span> 
             <span>VarHandle的变量类型是组件类型<code>arrayClass</code> ，坐标类型列表为<code>(arrayClass, int)</code> ，其中<code>int</code>坐标类型对应于作为数组索引的参数。</span> 
             <p> <span>在以下情况下，不支持返回的VarHandle的某些访问模式：</span> </p> 
             <ul> 
              <li> <span>如果组件类型以外的任何其他<code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code> ，或<code>double</code>然后数字原子更新的接入方式是不受支持的。</span> </li> 
              <li> <span>如果字段的类型是以外的任何其他<code>boolean</code> ， <code>byte</code> ， <code>short</code> ， <code>char</code> ， <code>int</code>或<code>long</code>然后逐位原子更新的接入方式是不受支持的。</span> </li> 
             </ul> 
             <p> <span>如果组件类型为<code>float</code>或<code>double</code>则数字和原子更新访问模式使用其按位表示比较值（分别见<a href="../../../java/lang/Float.html#floatToRawIntBits-float-"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../../../java/lang/Double.html#doubleToRawLongBits-double-"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>由数字和原子更新访问模式执行的<code>float</code>值或<code>double</code>值的按位比较不同于原语<code>==</code>运算符和<a href="../../../java/lang/Float.html#equals-java.lang.Object-"><code>Float.equals(java.lang.Object)</code></a>和<a href="../../../java/lang/Double.html#equals-java.lang.Object-"><code>Double.equals(java.lang.Object)</code></a>方法，特别是关于比较NaN值或比较<code>-0.0</code>与<code>+0.0</code> 。</span> 
              <span>当执行比较和设置或与这些值的比较和交换操作时，应注意，因为操作可能会意外失败。</span> 
              <span>在Java中，许多可能的NaN值被认为是<code>NaN</code> ，尽管Java提供的IEEE 754浮点运算没有区别它们。</span> 
              <span>如果预期值或见证值为NaN值，并且将其转换（可能以平台特定方式）为另一个NaN值，因此具有不同的逐位表示（参见<a href="../../../java/lang/Float.html#intBitsToFloat-int-"><code>Float.intBitsToFloat(int)</code></a>或<a href="../../../java/lang/Double.html#longBitsToDouble-long-"><code>Double.longBitsToDouble(long)</code></a>更多详细信息），则可能会发生操作失败。</span> 
              <span>值<code>-0.0</code>和<code>+0.0</code>具有不同的位图表示，但在使用基元<code>==</code>运算符时被认为是相等的。</span> 
              <span>如果，例如，数字算法计算的预期值是说可能会出现操作故障<code>-0.0</code>和先前计算的见证价值被说<code>+0.0</code> 。</span> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>arrayClass</code> - 一个数组的类，类型为 
              <code>T[]</code> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle可以访问数组的元素 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果arrayClass为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果arrayClass不是数组类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="byteArrayViewVarHandle-java.lang.Class-java.nio.ByteOrder-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>byteArrayViewVarHandle</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;byteArrayViewVarHandle​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;viewArrayClass,
                                               <a href="../../../java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)
                                        throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生一个VarHandle，可以访问<code>byte[]</code>数组的元素，就像它是一个不同的基本数组类型，如<code>int[]</code>或<code>long[]</code> 。</span> 
             <span>VarHandle的变量类型是组件类型<code>viewArrayClass</code> ，坐标类型列表为<code>(byte[], int)</code> ，其中<code>int</code>坐标类型对应于作为<code>byte[]</code>数组的索引的参数。</span> 
             <span>返回的VarHandle将访问<code>byte[]</code>数组中的索引处的字节，根据给定的字节顺序组合字节到组件类型<code>viewArrayClass</code>的值。</span> 
             <p> <span>支持的组件类型（变量类型）是<code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p> 
             <p> <span>一个给定的索引处的字节的访问将导致<code>IndexOutOfBoundsException</code> ，如果指数小于<code>0</code>比大于或<code>byte[]</code>的阵列长度减去的大小（以字节计） <code>T</code> 。</span> </p> 
             <p> <span>对于<code>T</code> ，索引中的字节访问可能对齐或不对齐，相对于与阵列和索引相关联的底层内存地址<code>A</code> 。</span> <span>如果访问未对齐，则访问除<code>get</code>和<code>set</code>访问模式之外的任何内容将导致<code>IllegalStateException</code> 。</span> <span>在这种情况下，原子访问只能保证二分之一的最大功率为<code>A</code> ，GCD为<code>A</code> ，而大小（以字节为单位）为<code>T</code> 。</span> <span>如果访问对齐，则支持以下访问模式，并保证支持原子访问：</span> </p> 
             <ul> 
              <li> <span>读取所有<code>T</code>写访问模式，但访问模式<code>get</code>和<code>set</code>用于<code>long</code>和<code>double</code>在32位平台上。</span> </li> 
              <li> <span>原子更新的接入方式为<code>int</code> ， <code>long</code> ， <code>float</code>或<code>double</code> 。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的其他类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>数字原子更新访问模式。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的附加数字类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>逐位原子更新访问模式。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的附加数字类型。）</span> </li> 
             </ul> 
             <p> <span>对于<code>byte[]</code>阵列， <code>byte[]</code>不对齐的访问，因此原子性保证，而不在特定数组上操作。</span> <span>给定一个<code>index</code> ， <code>T</code>和它的对应的盒装类型， <code>T_BOX</code> ，如下错位可以被确定：</span> </p> 
             <pre>  <span><code> int sizeOfT = T_BOX.BYTES; // size in bytes of T int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]). alignmentOffset(0, sizeOfT); int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT; boolean isMisaligned = misalignedAtIndex != 0; </code></span> </pre> 
             <p> <span>如果变量类型是<code>float</code>或<code>double</code>那么原子更新访问模式使用它们的按位表示比较值（分别见<a href="../../../java/lang/Float.html#floatToRawIntBits-float-"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../../../java/lang/Double.html#doubleToRawLongBits-double-"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>viewArrayClass</code> - 视图数组类，组件类型为 
              <code>T</code> 
             </dd> 
             <dd> 
              <code>byteOrder</code> - 视图数组元素的字节顺序，存储在底层的 
              <code>byte</code>数组中 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle可以访问一个 
              <code>byte[]</code>数组的元素，如同对应于视图数组类的组件类型的元素 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果viewArrayClass或byteOrder为null 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果viewArrayClass不是数组类型 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
              <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code>的组件类型不支持作为变量类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="byteBufferViewVarHandle-java.lang.Class-java.nio.ByteOrder-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>byteBufferViewVarHandle</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a>&nbsp;byteBufferViewVarHandle​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;viewArrayClass,
                                                <a href="../../../java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;byteOrder)
                                         throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
            <div class="block"> 
             <span>产生VarHandle给予访问的元素<code>ByteBuffer</code>视为好像它是一个不同的基本组件类型到的元件的阵列<code>byte</code> ，如<code>int[]</code>或<code>long[]</code> 。</span> 
             <span>VarHandle的变量类型是组件类型<code>viewArrayClass</code> ，坐标类型列表为<code>(ByteBuffer, int)</code> ，其中<code>int</code>坐标类型对应于作为<code>byte[]</code>数组的索引的参数。</span> 
             <span>返回VarHandle的指数下访问以字节<code>ByteBuffer</code> ，构成字节或从的部件类型的值<code>viewArrayClass</code>根据给定的字节顺序。</span> 
             <p> <span>支持的组件类型（变量类型）是<code>short</code> ， <code>char</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>和<code>double</code> 。</span> </p> 
             <p> <span>如果<code>ByteBuffer</code>为只读，访问将导致<code>ReadOnlyBufferException</code>用于读取访问模式之外的任何其他操作。</span> </p> 
             <p> <span>一个给定的索引处的字节的访问将导致<code>IndexOutOfBoundsException</code> ，如果指数小于<code>0</code>比大于或<code>ByteBuffer</code>的限值减去的大小（以字节计） <code>T</code> 。</span> </p> 
             <p> <span>对于<code>T</code> ，索引中的字节访问可能对齐或不对齐，相对于底层内存地址， <code>A</code>表示与<code>ByteBuffer</code>和索引相关联。</span> <span>如果访问未对齐，则访问除<code>get</code>和<code>set</code>访问模式之外的任何内容将导致<code>IllegalStateException</code> 。</span> <span>在这种情况下的原子访问仅相对于划分的GCD的两个最大功率保证<code>A</code>的和的大小（以字节计） <code>T</code> 。</span> <span>如果访问对齐，则支持以下访问模式，并保证支持原子访问：</span> </p> 
             <ul> 
              <li> <span>读取所有<code>T</code>写入访问模式，除了访问模式<code>get</code>和<code>set</code>用于<code>long</code>和<code>double</code>在32位平台上。</span> </li> 
              <li> <span>原子更新的接入方式为<code>int</code> ， <code>long</code> ， <code>float</code>或<code>double</code> 。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的其他类型。）</span> </li> 
              <li> <span><code>int</code>和<code>long</code>数字原子更新访问模式。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的附加数字类型。）</span> </li> 
              <li> <span>按位原子更新访问模式为<code>int</code>和<code>long</code> 。</span> <span>（JDK的未来主要平台版本可能会支持某些当前不支持的访问模式的附加数字类型。）</span> </li> 
             </ul> 
             <p> <span>未对齐存取，因此原子性保证，可以为被确定<code>ByteBuffer</code> ， <code>bb</code> （直接或以其它方式），一个<code>index</code> ， <code>T</code>和它的对应的盒装类型， <code>T_BOX</code> ，如下所示：</span> </p> 
             <pre>  <span><code> int sizeOfT = T_BOX.BYTES; // size in bytes of T ByteBuffer bb = ... int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT); boolean isMisaligned = misalignedAtIndex != 0; </code></span> </pre> 
             <p> <span>如果变量类型为<code>float</code>或<code>double</code>那么原子更新访问模式使用其逐位表示比较值（分别见<a href="../../../java/lang/Float.html#floatToRawIntBits-float-"><code>Float.floatToRawIntBits(float)</code></a>和<a href="../../../java/lang/Double.html#doubleToRawLongBits-double-"><code>Double.doubleToRawLongBits(double)</code></a> ）。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>viewArrayClass</code> - 视图数组类，组件类型为 
              <code>T</code> 
             </dd> 
             <dd> 
              <code>byteOrder</code> - 视图数组元素的字节顺序，存储在底层的 
              <code>ByteBuffer</code> （注意这覆盖了一个 
              <code>ByteBuffer</code>的字节顺序） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个VarHandle给予访问的元素 
              <code>ByteBuffer</code>仿佛对应于该部件类型的视图阵列类的元素观察 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果viewArrayClass或byteOrder为null 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果viewArrayClass不是数组类型 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - 如果 
              <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code>的组件类型不支持作为变量类型 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="spreadInvoker-java.lang.invoke.MethodType-int-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>spreadInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;spreadInvoker​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type,
                                         int&nbsp;leadingArgCount)</pre> 
            <div class="block"> 
             <span>产生一个方法句柄，它将调用给定的<code>type</code>任何方法句柄，给定的尾随参数被单个尾随的<code>Object[]</code>数组替换。</span> 
             <span>生成的调用者将是一个方法句柄，其中包含以下参数：</span> 
             <ul> 
              <li> <span>一个<code>MethodHandle</code>目标</span> </li> 
              <li> <span>零个或多个领先价值（按<code>leadingArgCount</code>计算）</span> </li> 
              <li> <span>一个包含尾随参数的<code>Object[]</code>数组</span> </li> 
             </ul> 
             <p> <span>调用者将调用其目标像一个电话<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>与指示<code>type</code> 。</span> <span>也就是说，如果目标是给定的<code>type</code> ，它的行为就像<code>invokeExact</code> ;</span> <span>否则表现为使用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>将目标转换为所需的<code>type</code> 。</span> </p> 
             <p> <span>类型返回调用者将不给定<code>type</code> ，而是将具有除第一所有参数<code>leadingArgCount</code>由类型的单个阵列代替<code>Object[]</code> ，这将是最终的参数。</span> </p> 
             <p> <span>在调用其目标之前，调用者将传播最终的数组，根据需要应用引用转换，并解开并扩展原始参数。</span> <span>如果调用调用者时，所提供的数组参数不具有正确数量的元素，调用者将抛出一个<a href="../../../java/lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>而不是调用目标。</span> </p> 
             <p> <span>此方法等同于以下代码（尽管可能更有效）：</span> </p> 
             <blockquote> 
              <span><pre><code>
MethodHandle invoker = MethodHandles.invoker(type);
int spreadArgCount = type.parameterCount() - leadingArgCount;
invoker = invoker.asSpreader(Object[].class, spreadArgCount);
return invoker;
 </code></pre></span> 
             </blockquote> 
             <span>此方法不会引发反思或安全异常。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dd> 
              <code>leadingArgCount</code> - 固定参数的数量，不会更改为目标 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适用于调用给定类型的任何方法句柄的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>type</code>为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>leadingArgCount</code>不在0到 
              <code>type.parameterCount()</code> ，或者如果所得到的方法手柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="exactInvoker-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>exactInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;exactInvoker​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用者方法句柄</em> ，可以用于调用给定类型的任何方法句柄，如<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code>所示</a> 。</span> 
             <span>所得到的调用者将具有与所需类型完全相同的类型，除了它将接受类型为<code>MethodHandle</code>的另外的前导参数。</span> 
             <p> <span>此方法相当于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invokeExact", type)</code></span> </p> 
             <p style="font-size:smaller;"> <span><em>讨论：</em>当使用未知类型的变量方法句柄时，Invoker方法句柄可能很有用。</span> <span>例如，要模拟一个<code>invokeExact</code>调用变量方法句柄<code>M</code> ，提取其类型为<code>T</code> ，查询调用方法<code>X</code>为<code>T</code> ，并调用invoker方法，如<code>X.invoke(T, A...)</code> 。</span> <span>（调用<code>X.invokeExact</code> ，因为类型为<code>T</code>未知。）如果需要进行扩展，收集或其他参数转换，则可以将其应用于调用者<code>X</code> ，并重用于许多<code>M</code>方法句柄值，只要它们与<code>X</code>的类型兼容。</span> </p> 
             <p style="font-size:smaller;"> <span><em>（注意：通过Core Reflection API不能使用调用者方法，在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method.invoke</a>的方法将会产生一个<a href="../../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> ））</em></span> </p> 
             <p> <span>此方法不会引发反思或安全异常。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适用于调用给定类型的任何方法句柄的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果生成的方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="invoker-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>invoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;invoker​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成一个特殊的<em>调用方法句柄</em> ，可以用于调用与给定类型兼容的任何方法句柄，就像通过<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code>一样</a> 。</span> 
             <span>生成的调用者将具有与所需类型完全相同的类型，但它将接受类型为<code>MethodHandle</code>的其他前导参数。</span> 
             <p> <span>在调用其目标之前，如果目标与预期的类型不同，则调用者将根据需要应用引用转换，并且将box，unbox或者扩展原始值，如同通过<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>一样</a> 。</span> <span>类似地，返回值将根据需要进行转换。</span> <span>如果目标是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity method handle</a> ，则将进行所需的转换，再次如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>所示</a> 。</span> </p> 
             <p> <span>此方法等同于以下代码（尽管可能更有效）： <code>publicLookup().findVirtual(MethodHandle.class, "invoke", type)</code></span> </p> 
             <p style="font-size:smaller;"> <span><em>讨论：</em> A <a href="../../../java/lang/invoke/MethodType.html#genericMethodType-int-boolean-">general method type</a>是一个仅提及<code>Object</code>参数和返回值的参数。</span> <span>这种类型的调用者能够调用与一般类型相同的任何方法句柄。</span> </p> 
             <p style="font-size:smaller;"> <span><em>（注意：通过Core Reflection API不可以使用调用者方法，在声明的<code>invokeExact</code>或<code>invoke</code>方法上调用<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-">java.lang.reflect.Method.invoke</a>的方式将会引发一个<a href="../../../java/lang/UnsupportedOperationException.html" title="java.lang中的类"><code>UnsupportedOperationException</code></a> ））</em></span> </p> 
             <p> <span>此方法不会引发反思或安全异常。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适用于调用可转换为给定类型的任何方法句柄的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果结果方法句柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="varHandleExactInvoker-java.lang.invoke.VarHandle.AccessMode-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>varHandleExactInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;varHandleExactInvoker​(<a href="../../../java/lang/invoke/VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode,
                                                 <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>产生一个特殊的<em>调用者方法句柄</em> ，可以用于在任何与其给定类型相关联的访问模式类型的VarHandle上调用签名多态访问模式方法。</span> 
             <span>生成的调用者将具有与所需给定类型完全相同的类型，但它将接受类型为<code>VarHandle</code>的其他前导参数。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - VarHandle访问模式 
             </dd> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适用于调用其访问模式类型为给定类型的任何VarHandle的访问模式方法的方法句柄。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="varHandleInvoker-java.lang.invoke.VarHandle.AccessMode-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>varHandleInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;varHandleInvoker​(<a href="../../../java/lang/invoke/VarHandle.AccessMode.html" title="enum in java.lang.invoke">VarHandle.AccessMode</a>&nbsp;accessMode,
                                            <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>产生一个特殊的<em>调用者方法句柄</em> ，可以用于在任何与其给定类型相关联的访问模式类型的VarHandle上调用签名多态访问模式方法。</span> 
             <span>生成的调用者将具有与所需给定类型完全相同的类型，但它将接受类型为<code>VarHandle</code>的其他前导参数。</span> 
             <p> <span>在调用其目标之前，如果访问模式类型与所需的给定类型不同，则调用者将根据需要应用引用转换，并且将box，unbox或者扩展原始值，如同通过<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code>一样</a> 。</span> <span>类似地，返回值将根据需要进行转换。</span> </p> 
             <p> <span>此方法等效于以下代码（尽管可能会更有效）： <code>publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)</code></span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>accessMode</code> - VarHandle访问模式 
             </dd> 
             <dd> 
              <code>type</code> - 所需的目标类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               适用于调用其访问模式类型可转换为给定类型的任何VarHandle的访问模式方法的方法句柄。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>explicitCastArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;explicitCastArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                                 <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</pre> 
            <div class="block"> 
             <span>生成方法句柄，通过成对参数和返回类型转换将给定方法句柄的类型适配为新类型。</span> 
             <span>原始类型和新类型必须具有相同数量的参数。</span> 
             <span>生成的方法句柄保证报告一个等于所需新类型的类型。</span> 
             <p> <span>如果原始类型和新类型相等，则返回目标。</span> </p> 
             <p> <span>允许使用与<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType</code></a>相同的转换，如果这些转换失败，还会应用一些其他转化。</span> <span>给定类型<em>T0</em> ， <em>T1</em> ，如果可能，应用以下转换之一，之前或代替<code>asType</code>完成的任何转换：</span> </p> 
             <ul> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是引用，并且<em>T1</em>是接口类型，则类型<em>T0</em>的值作为<em>T1</em>传递，而不进行转换。</span> <span>（这种接口的处理遵循字节码验证器的使用。）</span> </li> 
              <li> <span>如果<em>T0</em>是布尔值， <em>T1</em>是另一个原语，则布尔值转换为字节值，1为真，0为false。</span> <span>（此处理遵循字节码验证器的使用。）</span> </li> 
              <li> <span>如果<em>T1</em>是布尔值， <em>T0</em>是另一个原语，则通过Java转换（JLS 5.5）将<em>T0</em>转换为字节，并测试结果的低位，如同<code>(x &amp; 1) != 0</code> 。</span> </li> 
              <li> <span>如果<em>T0</em>和<em>T1</em>是除布尔值之外的基元，则应用Java转换（JLS 5.5）。</span> <span>（具体来说， <em>T0</em>将通过加宽和/或变窄而转换为<em>T1</em> ）</span> </li> 
              <li> <span>如果<em>T0</em>是引用， <em>T1</em>是原语，则在运行时将应用拆箱转换，可能之后是对原始值进行Java转换（JLS 5.5），之后可以通过测试低阶转换为字节到布尔位。</span> </li> 
              <li> <span>如果<em>T0</em>是引用， <em>T1</em>是一个原语，并且如果引用在运行时为空，则引入零值。</span> </li> 
             </ul> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 重新输入参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>newType</code> - 新方法句柄的预期类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在执行任何必要的参数转换后委托给目标的方法句柄，并安排任何必要的返回值转换 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - 如果不能进行转换 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType(java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>permuteArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;permuteArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType,
                                            int...&nbsp;reorder)</pre> 
            <div class="block"> 
             <span>生成方法句柄，通过重新排序参数，将方法句柄调整到新类型的调用顺序。</span> 
             <span>生成的方法句柄保证报告一个等于所需新类型的类型。</span> 
             <p> <span>给定的数组控制重新排序。</span> <span>调用<code>#I</code>输入参数的数量（值<code>newType.parameterCount()</code> ，并调用<code>#O</code>输出参数的数量（值<code>target.type().parameterCount()</code> ），然后重新排序数组的长度必须为<code>#O</code> ，每个元素必须为小于<code>#I</code>的非负数对于每<code>N</code>小于<code>#O</code> ，所述<code>N</code>个传出参数将被从所拍摄的<code>I</code>个传入的参数，其中<code>I</code>是<code>reorder[N]</code> 。</span> </p> 
             <p> <span>不应用参数或返回值转换。</span> <span>由<code>newType</code>确定的每个传入参数的类型必须与目标方法句柄中对应的传出参数或参数的类型相同。</span> <span><code>newType</code>的返回类型必须与原始目标的返回类型相同。</span> </p> 
             <p> <span>重排序数组不需要指定实际的排列。</span> <span>如果其索引在数组中出现多次，则传入的参数将被重复，如果引用参数的索引未出现在数组中，则传入参数将被删除。</span> <span>与<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>的情况<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">一样</a> ，重新排序数组中未提及的传入参数可以是任何类型，仅由<code>newType</code>确定。</span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodType intfn1 = methodType(int.class, int.class);
MethodType intfn2 = methodType(int.class, int.class, int.class);
MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
assert(sub.type().equals(intfn2));
MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
assert((int)rsub.invokeExact(1, 100) == 99);
MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
assert(add.type().equals(intfn2));
MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
assert(twice.type().equals(intfn1));
assert((int)twice.invokeExact(21) == 42);
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器从不是一个<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 在参数之后调用的方法句柄被重新排序 
             </dd> 
             <dd> 
              <code>newType</code> - 新方法句柄的预期类型 
             </dd> 
             <dd> 
              <code>reorder</code> - 控制重新排序的索引数组 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，它在它删除未使用的参数并移动和/或复制其他参数之后委托给目标 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果索引数组长度不等于目标的arity，或者如果任何索引数组元素不是 
              <code>newType</code>的参数的有效索引，或者如果 
              <code>target.type()</code>和 
              <code>newType</code>中的两个对应的参数类型不相同， 
             </dd> 
            </dl> </li> 
          </ul> <a id="constant-java.lang.Class-java.lang.Object-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>constant</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;constant​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type,
                                    <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;value)</pre> 
            <div class="block"> 
             <span>生成请求的返回类型的方法句柄，每次调用时返回给定的常量值。</span> 
             <p> <span>在返回方法句柄之前，将传入值转换为请求的类型。</span> <span>如果请求的类型是原始的，则尝试扩大原始转换，否则尝试参考转换。</span> </p> 
             <p> <span>返回的方法句柄相当于<code>identity(type).bindTo(value)</code> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的返回类型 
             </dd> 
             <dd> 
              <code>value</code> - 要返回的值 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定返回类型的方法句柄，并且没有参数，它始终返回给定的值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>type</code>参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - 如果该值无法转换为所需的返回类型 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定类型是 
              <code>void.class</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="identity-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>identity</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;identity​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type)</pre> 
            <div class="block">
              生成方法句柄，在调用时返回其唯一参数。 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的唯一参数和返回值的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               接受并返回给定类型的一元方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果给定类型是 
              <code>void.class</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="zero-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>zero</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;zero​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;type)</pre> 
            <div class="block"> 
             <span>生成请求的返回类型的常量方法句柄，每次调用时返回该类型的默认值。</span> 
             <span>得到的常量方法句柄将没有副作用。</span> 
             <p> <span>返回的方法句柄相当于<code>empty(methodType(type))</code> 。</span> <span>它也相当于<code>explicitCastArguments(constant(Object.class, null), methodType(type))</code> ，因为<code>explicitCastArguments</code>将<code>null</code>转换为默认值。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 期望的方法句柄的返回类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个常量方法句柄，不带参数并返回给定类型的默认值（如果该类型为void，则为void） 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-"><code>constant(java.lang.Class&lt;?&gt;, java.lang.Object)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-"><code>empty(java.lang.invoke.MethodType)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-"><code>explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="empty-java.lang.invoke.MethodType-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>empty</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;empty​(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
            <div class="block"> 
             <span>产生一个忽略任何参数的请求类型的方法句柄，不执行任何操作，并根据返回类型返回合适的默认值。</span> 
             <span>也就是说，它返回一个零原始值，一个<code>null</code>或<code>void</code> 。</span> 
             <p> <span>返回的方法句柄相当于<code>dropArguments(zero(type.returnType()), 0, type.parameterList())</code> 。</span> </p> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd>
               给定一个谓词和目标，一个有用的“if-then”结构可以生成为 
              <code>guardWithTest(pred, target, empty(target.type())</code> 。 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>type</code> - 所需方法句柄的类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               给定类型的常量方法句柄，它返回给定返回类型的默认值 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果参数为空 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#zero-java.lang.Class-"><code>zero(java.lang.Class&lt;?&gt;)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-"><code>constant(java.lang.Class&lt;?&gt;, java.lang.Object)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>insertArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;insertArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;values)</pre> 
            <div class="block"> 
             <span>在方法句柄的调用之前提供一个具有一个或多个<em>绑定参数</em>的目标方法句柄。</span> 
             <span>对应于绑定参数的目标的形式参数称为<em>绑定参数</em> 。</span> 
             <span>返回一个新的方法句柄，可以省去绑定的参数。</span> 
             <span>当它被调用时，它会接收任何非绑定参数的参数，将保存的参数绑定到其对应的参数，并调用原始目标。</span> 
             <p> <span>新方法句柄的类型将从原始目标类型中删除绑定参数的类型，因为新方法句柄将不再需要这些参数由其调用者提供。</span> </p> 
             <p> <span>每个给定的参数对象必须匹配相应的绑定参数类型。</span> <span>如果绑定的参数类型是一个原语，则参数对象必须是包装器，并且将被取消装箱以产生原始值。</span> </p> 
             <p> <span><code>pos</code>参数选择要绑定的参数。</span> <span>它可以在零和<i>NL</i>之间（包括），其中<i>N</i>是目标方法句柄的粗细， <i>L</i>是值数组的长度。</span> </p> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器永远不会是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 插入参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 在哪里插入参数（零为第一个） 
             </dd> 
             <dd> 
              <code>values</code> - 插入的一系列参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               在调用原始方法句柄之前插入附加参数的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标或 
              <code>values</code>数组为空 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-"><code>MethodHandle.bindTo(java.lang.Object)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&gt;&nbsp;valueTypes)</pre> 
            <div class="block"> 
             <span>产生的方法处理这将调用一些其他指定的<i>目标</i>方法句柄之前丢弃一些伪参数。</span> 
             <span>新方法句柄的类型将与目标类型相同，但在某些给定位置，它也包括虚拟参数类型。</span> 
             <p> <span><code>pos</code>参数可以介于零和<i>N</i>之间，其中<i>N</i>是目标的空间。</span> <span>如果<code>pos</code>为零，则虚拟参数将在目标的实<code>pos</code>之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会来。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
assertEquals(bigType, d0.type());
assertEquals("yz", (String) d0.invokeExact(123, "x", "y", "z"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>此方法也等效于以下代码：</span> </p> 
             <blockquote> 
              <span><pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"><code>dropArguments</code></a><code>(target, pos, valueTypes.toArray(new Class[0]))</code>
 </pre></span> 
             </blockquote> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 删除参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>valueTypes</code> - 要删除的参数的类型 
             </dd> 
             <dd> 
              <code>pos</code> - 第一个参数的位置（最左边为零） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，在调用原始方法句柄之前删除给定类型的参数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null，或者如果 
              <code>valueTypes</code>列表或其任何元素为null 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
              <code>valueTypes</code>为 
              <code>void.class</code> ，或者如果 
              <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型将有太多的参数 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;...&nbsp;valueTypes)</pre> 
            <div class="block"> 
             <span>产生的方法处理这将调用一些其他指定的<i>目标</i>方法句柄之前丢弃一些伪参数。</span> 
             <span>新方法句柄的类型将与目标类型相同，但在某些给定位置，它也包括虚拟参数类型。</span> 
             <p> <span><code>pos</code>参数的范围可以介于零和<i>N</i>之间，其中<i>N</i>是目标的概率。</span> <span>如果<code>pos</code>为零，则虚拟参数将在目标的实<code>pos</code>之前;</span> <span>如果<code>pos</code>是<i>N，</i>他们会来。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <blockquote> 
               <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle d0 = dropArguments(cat, 0, String.class);
assertEquals("yz", (String) d0.invokeExact("x", "y", "z"));
MethodHandle d1 = dropArguments(cat, 1, String.class);
assertEquals("xz", (String) d1.invokeExact("x", "y", "z"));
MethodHandle d2 = dropArguments(cat, 2, String.class);
assertEquals("xy", (String) d2.invokeExact("x", "y", "z"));
MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
assertEquals("xz", (String) d12.invokeExact("x", 12, true, "z"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>此方法也等效于以下代码：</span> </p> 
              <blockquote> 
               <span><pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a><code>(target, pos, Arrays.asList(valueTypes))</code>
 </pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 删除参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>valueTypes</code> - 要删除的参数的类型 
             </dd> 
             <dd> 
              <code>pos</code> - 第一个参数的位置（最左边为零） 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个方法句柄，在调用原始方法句柄之前删除给定类型的参数 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为空，或者如果 
              <code>valueTypes</code>数组或其任何元素为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元素 
              <code>valueTypes</code>为 
              <code>void.class</code> ，或者如果 
              <code>pos</code>比目标的元数负或更大，或者如果新的方法处理的类型将有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="dropArgumentsToMatch-java.lang.invoke.MethodHandle-int-java.util.List-int-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>dropArgumentsToMatch</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArgumentsToMatch​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                                int&nbsp;skip,
                                                <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&gt;&nbsp;newTypes,
                                                int&nbsp;pos)</pre> 
            <div class="block"> 
             <span>适应目标方法句柄以匹配给定的参数类型列表。</span> 
             <span>如有必要，添加虚拟参数。</span> 
             <span>匹配开始之前可以跳过一些引导参数。</span> 
             <span><code>target</code>的参数类型列表中的其余类型必须是起始位置<code>pos</code>处的<code>newTypes</code>类型列表的子列表。</span> 
             <span>所得到的句柄将具有目标句柄的参数类型列表，其中插入到目标原始参数的相应位置中的任何不匹配的参数类型（匹配子列表之前或之后），如同通过<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"><code>dropArguments(MethodHandle, int, Class[])</code>一样</a> 。</span> 
             <p> <span>所得到的句柄将具有与目标句柄相同的返回类型。</span> </p> 
             <p> <span>在更正式的术语中，假设这两个类型列表：</span> </p> 
             <ul> 
              <li> <span>目标句柄具有参数类型列表<code>S..., M...</code> ，其中<code>S</code>类型与<code>S</code>所示的类型<code>skip</code> 。</span> <span><code>M</code>类型是那些应该匹配给定类型列表<code>newTypes</code>一部分的类型。</span> </li> 
              <li> <span>该<code>newTypes</code>列表包含类型<code>P..., M..., A...</code> ，与许多类型<code>P</code>所指示<code>pos</code> 。</span> <span><code>M</code>类型正是目标句柄的参数类型列表中的<code>M</code>类型应该匹配的类型。</span> <span><code>A</code>中的类型是匹配子列表后面的其他类型。</span> </li> 
             </ul> 
             <span>给出这些假设，调用<code>dropArgumentsToMatch</code>的结果将具有参数类型列表<code>S..., P..., M..., A...</code> ，其中<code>P</code>和<code>A</code>类型被插入，如同通过<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"><code>dropArguments(MethodHandle, int, Class[])</code></a> 。</span> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>其参数列表“有效地相同”（即，在公共前缀中相同）的两个方法句柄可以通过对<code>dropArgumentsToMatch</code>的两次调用相互转换为公共类型，如下所示：</span> 
              <blockquote> 
               <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
...
MethodHandle h0 = constant(boolean.class, true);
MethodHandle h1 = lookup().findVirtual(String.class, "concat", methodType(String.class, String.class));
MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
if (h1.type().parameterCount() &lt; h2.type().parameterCount())
    h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
else
    h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
MethodHandle h3 = guardWithTest(h0, h1, h2);
assertEquals("xy", h3.invoke("x", "y", 1, "a", "b", "c"));
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 适应的方法句柄 
             </dd> 
             <dd> 
              <code>skip</code> - 要忽略的目标参数数（它们将保持不变） 
             </dd> 
             <dd> 
              <code>newTypes</code> - 匹配 
              <code>target</code>的参数类型列表的类型列表 
             </dd> 
             <dd> 
              <code>pos</code> - 位于 
              <code>newTypes</code> ，其中必须发生非跳过的目标参数 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个可能适应的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果任何元件 
              <code>newTypes</code>是 
              <code>void.class</code> ，或者如果 
              <code>skip</code>比目标的元数负或更大，或者如果 
              <code>pos</code>比newTypes列表尺寸负或更大，或者如果 
              <code>newTypes</code>不包含 
              <code>target</code>的非跳过位置 
              <code>pos</code>参数类型。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>filterArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</pre> 
            <div class="block"> 
             <span>通过预处理其一个或多个参数来适应目标方法句柄，每个参数具有自己的一元过滤器函数，然后使用每个预处理的参数替换为相应过滤器函数的结果来调用目标。</span> 
             <p> <span>预处理由一个或多个方法手柄执行，在<code>filters</code>数组的元素中指定。</span> <span>过滤器阵列的第一个元素对应于目标的<code>pos</code>参数，依次类推。</span> </p> 
             <p> <span>数组中的空参数被视为身份函数，相应的参数保持不变。</span> <span>（如果数组中没有非空元素，则返回原始目标。）每个过滤器都应用于适配器的相应参数。</span> </p> 
             <p> <span>如果过滤器<code>F</code>适用于目标的<code>N</code>参数，那么<code>F</code>必须是一个方法句柄， <code>F</code>需要一个参数。</span> <span><code>F</code>的唯一参数的类型将替换生成的适应方法句柄中的对象的相应参数类型。</span> <span><code>F</code>的返回类型必须与目标的相应参数类型相同。</span> </p> 
             <p> <span>如果有<code>filters</code> （null或not）的元素与目标中的参数位置不对应，则是错误的。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle upcase = lookup().findVirtual(String.class,
  "toUpperCase", methodType(String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle f0 = filterArguments(cat, 0, upcase);
assertEquals("Xy", (String) f0.invokeExact("x", "y")); // Xy
MethodHandle f1 = filterArguments(cat, 1, upcase);
assertEquals("xY", (String) f1.invokeExact("x", "y")); // xY
MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
assertEquals("XY", (String) f2.invokeExact("x", "y")); // XY
 </code></pre></span> 
             </blockquote> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>和最终的适配器的返回类型。</span> <span><code>P</code> / <code>p</code>和<code>B</code> / <code>b</code>表示之前和之后过滤器位置的参数和变量的类型和值<code>pos</code> ，分别。</span> <span><code>A[i]</code> / <code>a[i]</code>支架，用于将滤波参数和参数的类型和值;</span> <span>它们也代表了<code>filter[i]</code>句柄的返回类型。</span> <span>后者接受类型为<code>V[i]</code>参数<code>v[i]</code> ，这也出现在生成的适配器的签名中。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(P... p, A[i]... a[i], B... b);
 A[i] filter[i](V[i]);
 T adapter(P... p, V[i]... v[i], B... b) {
   return target(p..., filter[i](v[i])..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器从不是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 过滤参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 要过滤的第一个参数的位置 
             </dd> 
             <dd> 
              <code>filters</code> - 最初调用过滤参数的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄包含指定的参数过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果目标为null或者如果 
              <code>filters</code>数组为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果非空元件 
              <code>filters</code>如上所述不匹配目标的对应的参数类型，或者如果 
              <code>pos+filters.length</code>大于 
              <code>target.type().parameterCount()</code> ，或者如果产生的方法手柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>collectArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;collectArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            int&nbsp;pos,
                                            <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
            <div class="block"> 
             <span>通过使用过滤器（另一种方法句柄）预处理其参数的子序列来适应目标方法句柄。</span> 
             <span>预处理参数被过滤器函数的结果（如果有）替换。</span> 
             <span>然后在修改的（通常缩短的）参数列表上调用目标。</span> 
             <p> <span>如果过滤器返回一个值，则目标必须接受该值作为位置<code>pos</code>参数，前后和/或之后是未传递给过滤器的任何参数。</span> <span>如果过滤器返回void，则目标必须接受所有不传递给过滤器的参数。</span> <span>没有参数被重新排序，并且从过滤器返回的结果替换原来传递给适配器的参数的整个子序列（按顺序）。</span> </p> 
             <p> <span>过滤器的参数类型（如果有）替换了零或一个参数类型的目标，在位置<code>pos</code> ，在生成的修改方法句柄。</span> <span>过滤器的返回类型（如果有）必须与目标位置<code>pos</code>的参数类型相同，该目标参数由过滤器的返回值提供。</span> </p> 
             <p> <span>在所有情况下， <code>pos</code>必须大于或等于零，而<code>pos</code>也必须小于或等于目标的空间。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));

MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
assertEquals("[strange]", (String) ts1.invokeExact("strange"));

MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals("[up, down]", (String) ts2.invokeExact("up", "down"));

MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
assertEquals("[top, [up, down], strange]",
             (String) ts3_ts2.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
assertEquals("[top, [up, down], [strange]]",
             (String) ts3_ts2_ts1.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
assertEquals("[top, [[up, down, strange], charm], bottom]",
             (String) ts3_ts2_ts3.invokeExact("top", "up", "down", "strange", "charm", "bottom"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示的返回类型<code>target</code>并导致适配器。</span> <span><code>V</code> / <code>v</code>支架的的返回类型和值<code>filter</code> ，它们也在的签名和参数发现<code>target</code>分别，除非<code>V</code>是<code>void</code> 。</span> <span><code>A</code> / <code>a</code>和<code>C</code> / <code>c</code>代表参数的类型和值之前和之后的收集位置， <code>pos</code> ，在<code>target</code>的签名。</span> <span>他们所得到的适配器的签名和论据，在那里他们还围绕转动起来<code>B</code> / <code>b</code> ，它代表的参数类型和参数为<code>filter</code> （如果有的话）。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A...,V,C...);
 V filter(B...);
 T adapter(A... a,B... b,C... c) {
   V v = filter(b...);
   return target(a...,v,c...);
 }
 // and if the filter has no arguments:
 T target2(A...,V,C...);
 V filter2();
 T adapter2(A... a,C... c) {
   V v = filter2();
   return target2(a...,v,c...);
 }
 // and if the filter has a void return:
 T target3(A...,C...);
 void filter3(B...);
 T adapter3(A... a,B... b,C... c) {
   filter3(b...);
   return target3(a...,c...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span>收集适配器<code>collectArguments(mh, 0, coll)</code>等效于首先“折叠”受影响的参数，然后将它们分离出来，单独的步骤如下：</span> </p> 
             <blockquote> 
              <span><pre><code>
 mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
 mh = MethodHandles.foldArguments(mh, coll); //step 1
 </code></pre></span> 
             </blockquote> 
             <span>如果目标方法句柄除了过滤器<code>coll</code>的结果（如果有的话）以外没有任何参数，则<code>collectArguments(mh, 0, coll)</code>相当于<code>filterReturnValue(coll, mh)</code> 。</span> 
             <span>如果过滤器方法句柄<code>coll</code>消耗一个参数并产生无效结果，则<code>collectArguments(mh, N, coll)</code>相当于<code>filterArguments(mh, N, coll)</code> 。</span> 
             <span>其他等价是可能的，但需要参数置换。</span> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器从不是一个<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 过滤参数子序列后调用的方法句柄 
             </dd> 
             <dd> 
              <code>pos</code> - 传递给过滤器的第一个适配器参数的位置和/或接收过滤器结果的目标参数 
             </dd> 
             <dd> 
              <code>filter</code> - 方法句柄来调用参数的子序列 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，其包含指定的参数子序列过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果的返回类型 
              <code>filter</code>为非空隙和不一样的 
              <code>pos</code>目标的参数，或者如果 
              <code>pos</code>不为0之间以及在目标的元数，包括端值，或者如果产生的方法手柄的类型将具有 
              <a href="MethodHandle.html#maxarity">too many parameters</a> 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-"><code>filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>filterReturnValue</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterReturnValue​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
            <div class="block"> 
             <span>通过使用过滤器（另一种方法句柄）对其返回值（如果有的话）进行后处理来适应目标方法句柄。</span> 
             <span>从适配器返回过滤器的结果。</span> 
             <p> <span>如果目标返回值，则过滤器必须接受该值作为其唯一参数。</span> <span>如果目标返回void，则过滤器不能接受参数。</span> </p> 
             <p> <span>过滤器的返回类型替换生成的适应方法句柄中的目标的返回类型。</span> <span>过滤器的参数类型（如果有）必须与目标的返回类型相同。</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle length = lookup().findVirtual(String.class,
  "length", methodType(int.class));
System.out.println((String) cat.invokeExact("x", "y")); // xy
MethodHandle f0 = filterReturnValue(cat, length);
System.out.println((int) f0.invokeExact("x", "y")); // 2
 </code></pre></span> 
             </blockquote> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>中的代码， <code>T</code> / <code>t</code>表示的结果类型和值<code>target</code> ;</span> <span><code>V</code> ，结果类型为<code>filter</code> ;</span> <span>和<code>A</code> / <code>a</code> ，类型和所述参数和所述参数的值<code>target</code>以及所得到的适配器。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A...);
 V filter(T);
 V adapter(A... a) {
   T t = target(a...);
   return filter(t);
 }
 // and if the target has a void return:
 void target2(A...);
 V filter2();
 V adapter2(A... a) {
   target2(a...);
   return filter2();
 }
 // and if the filter has a void return:
 T target3(A...);
 void filter3(V);
 void adapter3(A... a) {
   T t = target3(a...);
   filter3(t);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器永远不会是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 过滤返回值之前调用的方法句柄 
             </dd> 
             <dd> 
              <code>filter</code> - 方法句柄来调用返回值 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄，其包含指定的返回值过滤逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果参数列表 
              <code>filter</code>不匹配目标的返回类型如上所述 
             </dd> 
            </dl> </li> 
          </ul> <a id="foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>foldArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;foldArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</pre> 
            <div class="block"> 
             <span>通过预处理一些参数来适应目标方法句柄，然后调用具有预处理结果的目标，插入到原始的参数序列中。</span> 
             <p> <span>预处理由<code>combiner</code>执行，第二个方法句柄。</span> <span>传递给适配器的参数中，第一个<code>N</code>参数被复制到组合器，然后调用它。</span> <span>（这里， <code>N</code>被定义为组合器的参数计数）。此后，控制传递给目标，任何来自组合器的结果在原始<code>N</code>传入参数之前插入。</span> </p> 
             <p> <span>如果组合器返回一个值，则目标的第一个参数类型必须与组合器的返回类型相同，而下一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p> 
             <p> <span>如果组合<code>N</code>返回，则不会插入结果，并且目标的第一个<code>N</code>参数类型必须与组合器的参数完全匹配。</span> </p> 
             <p> <span>生成的适配器与目标的类型相同，不同之处在于，如果第一个参数类型与组合器的结果相对应，那么它将被删除。</span> </p> 
             <p> <span>（请注意， <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>可用于删除组合器或目标不希望接收的任何参数。如果某些传入的参数仅用于组合器，请考虑使用<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector</code></a> ，因为这些参数不需要生活在堆栈上进入目标。）</span> </p> 
             <p> <span><b>例：</b></span> </p> 
             <blockquote> 
              <span><pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
  "println", methodType(void.class, String.class))
    .bindTo(System.out);
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
MethodHandle catTrace = foldArguments(cat, trace);
// also prints "boo":
assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre></span> 
             </blockquote> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>和结果适配器的结果类型。</span> <span><code>V</code> / <code>v</code>代表类型和所述参数和参数的值<code>target</code>先于折叠位置;</span> <span><code>V</code>也就是结果类型<code>combiner</code> 。</span> <span><code>A</code> / <code>a</code>表示类型和值<code>N</code>参数和变量在折叠位置。</span> <span><code>B</code> / <code>b</code>表示的类型和值<code>target</code>参数和变量的随后的折叠参数和参数。</span> </p> 
             <blockquote> 
              <span><pre><code>
 // there are N arguments in A...
 T target(V, A[N]..., B...);
 V combiner(A...);
 T adapter(A... a, B... b) {
   V v = combiner(a...);
   return target(v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(A[N]..., B...);
 void combiner2(A...);
 T adapter2(A... a, B... b) {
   combiner2(a...);
   return target2(a..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器从不是一个<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 组合参数后调用的方法句柄 
             </dd> 
             <dd> 
              <code>combiner</code> - 最初调用传入参数的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定参数折叠逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
              <code>combiner</code>的返回类型为非空隙和不一样的第一个参数类型的目标，或者如果初始 
              <code>N</code>参数类型的目标（跳过一个匹配 
              <code>combiner</code>的返回类型）不具有相同的参数类型为 
              <code>combiner</code> 
             </dd> 
            </dl> </li> 
          </ul> <a id="foldArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>foldArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;foldArguments​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</pre> 
            <div class="block"> 
             <span>通过预先处理一些参数，从给定的位置开始，然后调用具有预处理结果的目标，将其插入原来的参数序列之前，使其适用于目标方法句柄。</span> 
             <p> <span>该方法与<a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(MethodHandle, MethodHandle)</code></a>密切相关，但允许控制在折叠发生的参数列表中的位置。</span> <span>控制这个的参数， <code>pos</code> ，是一个零为基础的指数。</span> <span>上述方法<a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(MethodHandle, MethodHandle)</code></a>假定为位置0。</span> </p> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
    import static java.lang.invoke.MethodHandles.*;
    import static java.lang.invoke.MethodType.*;
    ...
    MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
    "println", methodType(void.class, String.class))
    .bindTo(System.out);
    MethodHandle cat = lookup().findVirtual(String.class,
    "concat", methodType(String.class, String.class));
    assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
    MethodHandle catTrace = foldArguments(cat, 1, trace);
    // also prints "jum":
    assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>表示<code>target</code>和结果适配器的结果类型。</span> <span><code>V</code> / <code>v</code>代表类型和所述参数和参数的值<code>target</code>先于折叠位置;</span> <span><code>V</code>也就是结果类型<code>combiner</code> 。</span> <span><code>A</code> / <code>a</code>表示类型和值<code>N</code>参数和变量在折叠位置。</span> <span><code>Z</code> / <code>z</code>和<code>B</code> / <code>b</code>表示的类型和值<code>target</code>参数和自变量之前和之后的折叠参数和自变量开始<code>pos</code>分别。</span> </p> 
              <blockquote> 
               <span><pre><code>
 // there are N arguments in A...
 T target(Z..., V, A[N]..., B...);
 V combiner(A...);
 T adapter(Z... z, A... a, B... b) {
   V v = combiner(a...);
   return target(z..., v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(Z..., A[N]..., B...);
 void combiner2(A...);
 T adapter2(Z... z, A... a, B... b) {
   combiner2(a...);
   return target2(z..., a..., b...);
 }
 </code></pre></span> 
              </blockquote> 
              <p> <span><em>注意：</em>即使原始的目标方法句柄是，生成的适配器永远不会是<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable-arity method handle</a> 。</span> </p> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 组合参数后调用的方法句柄 
             </dd> 
             <dd> 
              <span><code>pos</code> - 开始折叠的位置，插入折叠结果的位置;</span> 
              <span>如果是<code>0</code> ，效果与<a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(MethodHandle, MethodHandle)</code></a>相同。</span> 
             </dd> 
             <dd> 
              <code>combiner</code> - 最初调用传入参数的方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定参数折叠逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
             <dd> 
              <span><code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果满足以下两个条件成立：（1） <code>combiner</code>的返回类型是非<code>void</code>和不一样在位置参数类型<code>pos</code>目标签名的;</span> 
              <span>（2）目标签名的位置<code>pos</code>的<code>N</code>参数类型（跳过一个匹配<code>combiner</code>的返回类型）与<code>combiner</code>的参数类型<code>combiner</code> 。</span> 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>guardWithTest</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;guardWithTest​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</pre> 
            <div class="block"> 
             <span>使用方法句柄来调整目标方法句柄，通过用测试保护它，一个布尔值方法句柄。</span> 
             <span>如果防守失败，则会调用后备句柄。</span> 
             <span>所有三个方法句柄必须具有相同的对应参数和返回类型，除了测试的返回类型必须为布尔值，并且允许测试具有比其他两个方法句柄少的参数。</span> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>代表三个手柄的统一结果类型;</span> <span><code>A</code> / <code>a</code> ，类型和值<code>target</code>参数和参数是由消耗<code>test</code> ;</span> <span>和<code>B</code> / <code>b</code> ，这些类型和值<code>target</code>参数和自变量不是由消耗<code>test</code> 。</span> </p> 
             <blockquote> 
              <span><pre><code>
 boolean test(A...);
 T target(A...,B...);
 T fallback(A...,B...);
 T adapter(A... a,B... b) {
   if (test(a...))
     return target(a..., b...);
   else
     return fallback(a..., b...);
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，测试参数（伪代码中的<code>a...</code> ）不能通过执行测试进行修改，所以根据需要，从调用者不变地传递到目标或后备。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>test</code> - 用于测试的方法句柄，必须返回布尔值 
             </dd> 
             <dd> 
              <code>target</code> - 如果测试通过，调用方法句柄 
             </dd> 
             <dd> 
              <code>fallback</code> - 如果测试失败，则调用方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄包含指定的if / then / else逻辑 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>test</code>不返回布尔值，或者如果所有三种方法类型都不匹配（返回类型为 
              <code>test</code>更改为匹配目标）。 
             </dd> 
            </dl> </li> 
          </ul> <a id="catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>catchException</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;catchException​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType,
                                          <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</pre> 
            <div class="block"> 
             <span>通过在异常处理程序中运行它来创建适应目标方法句柄的方法句柄。</span> 
             <span>如果目标返回正常，则适配器返回该值。</span> 
             <span>如果抛出与指定类型匹配的异常，则会在异常时调用回退句柄，再加上原始参数。</span> 
             <p> <span>目标和处理程序必须具有相同的对应参数和返回类型，但处理程序可能会忽略拖尾参数（与<a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>guardWithTest</code>中</a>的谓词<a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">相似</a> ）。</span> <span>另外，处理程序必须有一个额外的引导参数<code>exType</code>或超类型。</span> </p> 
             <p> <span>这里是生成的适配器的伪代码。</span> <span>在代码中， <code>T</code>代表<code>target</code>和<code>handler</code>的返回类型，相应地代表所生成的适配器;</span> <span><code>A</code> / <code>a</code> ，类型和参数，以通过所消耗的所得句柄值<code>handler</code> ;</span> <span>和<code>B</code> / <code>b</code> ，那些参数，以通过丢弃所产生的手柄<code>handler</code> 。</span> </p> 
             <blockquote> 
              <span><pre><code>
 T target(A..., B...);
 T handler(ExType, A...);
 T adapter(A... a, B... b) {
   try {
     return target(a..., b...);
   } catch (ExType ex) {
     return handler(ex, a...);
   }
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，保存的参数（伪代码中的<code>a...</code> ）无法通过执行目标进行修改，如果调用处理程序，则从调用程序到处理程序不变地传递。</span> 
             <p> <span>目标和处理程序必须返回相同的类型，即使处理程序总是抛出。</span> <span>（这可能会发生，例如，因为处理程序正在模拟一个<code>finally</code>子句）。</span> <span>要创建这样的抛出处理程序，请使用<a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-"><code>throwException</code>编写</a>处理程序创建逻辑，以创建正确返回类型的方法句柄。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 方法句柄调用 
             </dd> 
             <dd> 
              <code>exType</code> - 处理程序将捕获的异常类型 
             </dd> 
             <dd> 
              <code>handler</code> - 如果抛出匹配的异常，则调用方法句柄 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               包含指定的try / catch逻辑的方法句柄 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>handler</code>不接受给定的异常类型，或者方法句柄类型在其返回类型及其相应参数中不匹配 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#tryFinally-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>tryFinally(MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="throwException-java.lang.Class-java.lang.Class-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>throwException</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;throwException​(<a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;?&gt;&nbsp;returnType,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">Class</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</pre> 
            <div class="block"> 
             <span>产生一个方法句柄，它将抛出给定的异常<code>exType</code> 。</span> 
             <span>方法句柄将接受一个单独的参数<code>exType</code> ，并立即将其作为例外。</span> 
             <span>方法类型将名义上指定返回值为<code>returnType</code> 。</span> 
             <span>返回类型可能是任何方便的：方法句柄的行为无关紧要，因为它将永远不会正常返回。</span> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>returnType</code> - 所需方法句柄的返回类型 
             </dd> 
             <dd> 
              <code>exType</code> - 所需方法句柄的参数类型 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               方法句柄可以抛出给定的异常 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任一参数为空 
             </dd> 
            </dl> </li> 
          </ul> <a id="loop-java.lang.invoke.MethodHandle:A...-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>loop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;loop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>[]...&nbsp;clauses)</pre> 
            <div class="block"> 
             <span>构造一个表示循环的方法句柄，该循环具有在每次迭代时更新和检查的多个循环变量。</span> 
             <span>在由于其中一个谓词终止循环后，运行相应的终结器，并传递循环的结果，循环的结果是结果句柄的返回值。</span> 
             <p> <span>直观地，每个循环由一个或多个“子句”形成，每个“子句”指定本地<em>迭代变量</em>和/或循环出口。</span> <span>循环的每次迭代按顺序执行每个子句。</span> <span>一个子句可以选择更新其迭代变量;</span> <span>它还可以选择执行测试和条件循环退出。</span> <span>为了在方法句柄方面表达这个逻辑，每个子句最多可以指定四个独立的动作：</span> </p> 
             <ul> 
              <li> <span><em>初始化：</em>在循环执行之前，一个迭代变量的初始化<code>v</code>类型的<code>V</code> 。</span> </li> 
              <li> <span><em>步骤：</em>当一个子句执行时，迭代变量<code>v</code>的更新步骤。</span> </li> 
              <li> <span><em>pred：</em>当一个子句执行时，一个谓词执行来测试循环退出。</span> </li> 
              <li> <span><em>fini：</em>如果一个子句导致循环退出，则执行终结器来计算循环的返回值。</span> </li> 
             </ul> 
             <span>所有迭代变量类型的完整序列按照子句顺序将被标记为<code>(V...)</code> 。</span> 
             <span>值本身将为<code>(v...)</code> 。</span> 
             <span>当我们说“参数列表”时，我们通常会指向类型，但在某些上下文（描述执行）中，列表将是实际值。</span> 
             <p> <span>这些条款部分中的一些可以根据某些规则被省略，并且在这种情况下提供有用的默认行为。</span> <span>详见下文。</span> </p> 
             <p> <span><em>参数可选无处不在：</em>每个子句函数是允许的，但不需要接受每个迭代变量<code>v</code>的参数。</span> <span>作为一个例外，init函数不能采用任何<code>v</code>参数，因为这些值在执行init函数时尚未计算。</span> <span>任何条款函数都可能忽略其有权采取的参数的任何后续子序列。</span> <span>实际上，任何子句函数都不会有参数。</span> </p> 
             <p> <span><em>循环参数：</em>一个子句函数可以使用它所有的迭代变量值，在这种情况下，它也可能需要更多的拖尾参数。</span> <span>这样的额外值被称为<em>循环参数</em> ，其类型和值被标记为<code>(A...)</code>和<code>(a...)</code> 。</span> <span>这些将成为所产生的循环句柄的参数，每当执行循环时，它将被提供。</span> <span>（由于init函数不接受迭代变量<code>v</code> ，init函数的任何参数都将自动为循环参数<code>a</code> ）。与迭代变量一样，子句函数是允许的，但不需要接受循环参数。</span> <span>这些循环参数用作整个循环中可见的循环不变值。</span> </p> 
             <p> <span><em>参数可见无处不在：</em>允许每个非init子句函数观察整个循环状态，因为它可以传递当前迭代变量值和传入循环参数的完整列表<code>(v... a...)</code> 。</span> <span>init函数可以观察初始的预循环状态，形式为<code>(a...)</code> 。</span> <span>大多数子句功能不需要所有这些信息，但它们将正式连接到它，就像<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments(java.lang.invoke.MethodHandle, int, java.util.List&lt;java.lang.Class&lt;?&gt;&gt;)</code>一样</a> 。</span> <span><a id="astar"></a>更具体地说，我们将使用符号<code>(V*)</code>来表达一个完整序列的任意前缀<code>(V...)</code> （且同样<code>(v*)</code> ， <code>(A*)</code> ， <code>(a*)</code> ）。</span> <span>在该符号中，init函数参数列表的一般形式为<code>(A*)</code> ，非init函数参数列表的一般形式为<code>(V*)</code>或<code>(V... A*)</code> 。</span> </p> 
             <p> <span><em>检查子句结构：</em>给定一组子句，执行多个检查和调整，以连接循环的所有部分。</span> <span>它们在下面的步骤中详细说明。</span> <span>在这些步骤中，如果循环组合器的输入不满足所需的约束，则单词“必须”的每次出现都对应于将抛出<a href="../../../java/lang/IllegalArgumentException.html" title="java.lang中的类"><code>IllegalArgumentException</code></a>的位置。</span> </p> 
             <p> <span><em>有效地相同的序列：</em> <a id="effid"></a>如果<code>A</code>和<code>B</code>是相同的，或者如果<code>A</code>较短并且与适当的前缀为<code>B</code>相同，则参数列表<code>A</code>被定义为<em>与</em>另一个参数列表<code>B</code> <em>有效地相同</em> 。</span> <span>当说出一组无序的参数列表时，我们认为如果集合包含最长列表，则该集合的整体“完全相同”，并且集合的所有成员与最长列表实际上相同。</span> <span>例如，任何一组的形式的型序列的<code>(V*)</code>是有效相同的，并且如果窗体的多个序列也是如此<code>(V... A*)</code>相加。</span> </p> 
             <p> <span><em>步骤0：确定子句结构。</em></span> </p> 
             <ol type="a"> 
              <li> <span>子句数组（型号为<code>MethodHandle[][]</code> ）必须为非<code>null</code>并且至少包含一个元素。</span> </li> 
              <li> <span>子句数组可能不包含长于四个元素的<code>null</code>或子数组。</span> </li> 
              <li> <span>短于四个元素的条款被视为被填充<code>null</code>元素长达四个。</span> <span>填充通过将元素附加到数组来进行。</span> </li> 
              <li> <span>条款与所有<code>null</code> s被忽略。</span> </li> 
              <li> <span>每个子句被视为一个四元组的函数，称为“init”，“step”，“pred”和“fini”。</span> </li> 
             </ol> 
             <p> <span><em>步骤1A：确定迭代变量类型<code>(V...)</code> 。</em></span> </p> 
             <ol type="a"> 
              <li> <span>每个子句的迭代变量类型使用子句的init和step返回类型来确定。</span> </li> 
              <li> <span>如果省略了两个函数，则对应的子句不存在迭代变量（ <code>void</code>用作指示的类型）。</span> <span>如果其中一个被忽略，其他的返回类型定义子句的迭代变量类型。</span> <span>如果两者都给出，那么常用的返回类型（它们必须相同）定义子句的迭代变量类型。</span> </li> 
              <li> <span>形成返回类型列表（按子句顺序），省略所有出现的<code>void</code> 。</span> </li> 
              <li> <span>这种类型的列表称为“迭代变量类型”（ <code>(V...)</code> ）。</span> </li> 
             </ol> 
             <p> <span><em>步骤1B：确定循环参数<code>(A...)</code> 。</em></span> </p> 
             <ul> 
              <li> <span>检查并收集init函数参数列表（其格式为<code>(A*)</code> ）。</span> </li> 
              <li> <span>在删除迭代变量类型后，检查并收集step，pred和fini参数列表的后缀。</span> <span>（他们必须具有<code>(V... A*)</code>的形式;仅收集<code>(A*)</code>部分。）</span> </li> 
              <li> <span>不要从没有以所有迭代变量类型开头的step，pred和fini参数列表收集后缀。</span> <span>（这些类型将在步骤2中检查，以及所有子句函数类型。）</span> </li> 
              <li> <span>省略的子句功能被忽略。</span> <span>（等同地，它们被认为具有空参数列表。）</span> </li> 
              <li> <span>所有收集的参数列表必须有效地相同。</span> </li> 
              <li> <span>最长参数列表（必须是唯一的）称为“外部参数列表”（ <code>(A...)</code> ）。</span> </li> 
              <li> <span>如果没有这样的参数列表，则将外部参数列表作为空序列。</span> </li> 
              <li> <span>由外部参数类型后面的迭代变量类型组成的组合列表称为“内部参数列表”。</span> </li> 
             </ul> 
             <p> <span><em>步骤1C：确定回路返回类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>检查fini函数返回类型，忽略忽略fini函数。</span> </li> 
              <li> <span>如果没有fini功能，循环返回类型为<code>void</code> 。</span> </li> 
              <li> <span>否则，fini函数的公共返回类型（它们的返回类型必须相同）的类型为<code>R</code>定义了循环返回类型。</span> </li> 
             </ol> 
             <p> <span><em>步骤1D：检查其他类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>必须至少有一个非省略的pred函数。</span> </li> 
              <li> <span>每个非省略的pred函数都必须有一个<code>boolean</code>返回类型。</span> </li> 
             </ol> 
             <p> <span><em>步骤2：确定参数列表。</em></span> </p> 
             <ol type="a"> 
              <li> <span>结果循环句柄的参数列表将是外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>init函数的参数列表将被调整为外部参数列表。</span> <span>（请注意，它们的参数列表已经与此列表有效相同）</span> </li> 
              <li> <span>每个非省略，非init（step，pred和fini）函数的参数列表必须与内部参数列表<code>(V... A...)</code>有效地相同。</span> </li> 
             </ol> 
             <p> <span><em>步骤3：填写省略功能。</em></span> </p> 
             <ol type="a"> 
              <li> <span>如果省略了一个init函数， <a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">那么</a>对于子句的迭代变量类型，请使用<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span>如果省略步骤功能，请使用该子句的迭代变量类型的<a href="../../../java/lang/invoke/MethodHandles.html#identity-java.lang.Class-">identity function</a> ;</span> <span>在前面的子句的非<code>void</code>迭代变量的identity函数之前插入参数参数。</span> <span>（这将使循环变量变为本地循环不变量。）</span> </li> 
              <li> <span>如果省略pred函数，请使用常数<code>true</code>函数。</span> <span>（这将保持循环，就本条而言，请注意，在这种情况下，相应的fini函数是无法访问的。</span> </li> 
              <li> <span>如果省略fini功能，请使用<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a>作为循环返回类型。</span> </li> 
             </ol> 
             <p> <span><em>步骤4：填写缺少的参数类型。</em></span> </p> 
             <ol type="a"> 
              <li> <span>此时，每个init函数参数列表与外部参数列表<code>(A...)</code>有效地相同，但是一些列表可能更短。</span> <span>对于具有短参数列表的每个初始化函数，请填写列表的末尾。</span> </li> 
              <li> <span>此时，每个非init函数参数列表与内部参数列表<code>(V... A...)</code>有效地相同，但是一些列表可能更短。</span> <span>对于每个具有短参数列表的非init函数，请填写列表的末尾。</span> </li> 
              <li> <span>参数列表由<a href="../../../java/lang/invoke/MethodHandles.html#dropArgumentsToMatch-java.lang.invoke.MethodHandle-int-java.util.List-int-boolean-">dropping unused trailing arguments</a>填充。</span> </li> 
             </ol> 
             <p> <span><em>最终观察。</em></span> </p> 
             <ol type="a"> 
              <li> <span>在这些步骤之后，通过提供省略的函数和参数来调整所有子句。</span> </li> 
              <li> <span>所有init函数都有一个常见的参数类型列表<code>(A...)</code> ，最后的循环句柄也将具有。</span> </li> 
              <li> <span>所有fini函数都有一个常见的返回类型<code>R</code> ，最后的循环句柄也将具有。</span> </li> 
              <li> <span>所有非init函数都有一个公共参数类型列表<code>(V... A...)</code> ，（非<code>void</code> ）迭代变量<code>V</code>后跟循环参数。</span> </li> 
              <li> <span>每对init和step函数在返回类型<code>V</code> 。</span> </li> 
              <li> <span>每个非init函数都能够观察到所有迭代变量的当前值<code>(v...)</code> 。</span> </li> 
              <li> <span>每个功能都能够观察所有循环参数的输入值<code>(a...)</code> 。</span> </li> 
             </ol> 
             <p> <span><em>例。</em></span> <span>作为上述步骤1A的结果， <code>loop</code>组合器具有以下属性：</span> </p> 
             <ul> 
              <li> <span>给予<code>N</code>条款<code>Cn = {null, Sn, Pn}</code>与<code>n = 1..N</code> 。</span> </li> 
              <li> <span>假设谓词句柄<code>Pn</code>是<code>null</code>或没有参数。</span> <span>（只有一个<code>Pn</code>必须是非<code>null</code> ）</span> </li> 
              <li> <span>假设步骤<code>Sn</code>具有签名<code>(B1..BX)Rn</code> ，对于一些常数<code>X&gt;=N</code> 。</span> </li> 
              <li> <span>假设<code>Q</code>是非空类型的<code>Rn</code> ，而这些类型的序列是<code>(V1...VQ)</code> 。</span> </li> 
              <li> <span>它必须是<code>Vn == Bn</code>为<code>n = 1..min(X,Q)</code> 。</span> </li> 
              <li> <span>参数类型<code>Vn</code>将被解释为循环本地状态元素<code>(V...)</code> 。</span> </li> 
              <li> <span>任何剩余的类型<code>BQ+1..BX</code> （如果为<code>Q&lt;X</code> ）将确定生成的循环句柄的参数类型<code>(A...)</code> 。</span> </li> 
             </ul> 
             <span>在这个例子中，循环句柄参数<code>(A...)</code>是从步骤函数中得出的，如果大部分循环计算发生在步骤中，这是很自然的。</span> 
             <span>对于某些循环，计算的负担可能在pred函数中最重，因此pred函数可能需要接受循环参数值。</span> 
             <span>对于具有复杂退出逻辑的循环，fini函数可能需要接受循环参数，同样对于具有复杂入口逻辑的循环，init函数将需要额外的参数。</span> 
             <span>由于这些原因，在所有条款部分中，确定这些参数的规则尽可能对称。</span> 
             <span>通常，循环参数作为整个循环中的公共不变值，而迭代变量用作常用变量值，或（如果没有步长函数）作为内部循环不变量临时值。</span> 
             <p> <span><em>循环执行。</em></span> </p> 
             <ol type="a"> 
              <li> <span>当循环被调用时，循环输入值被保存在本地，被传递给每个子句函数。</span> <span>这些本地是循环不变的。</span> </li> 
              <li> <span>每个init函数按子句顺序执行（传递外部参数<code>(a...)</code> ），非<code>void</code>值（作为迭代变量<code>(v...)</code> ）保存到本地文件中。</span> <span>这些本地人将是循环变化的（除非他们的步骤表现为身份功能，如上所述）。</span> </li> 
              <li> <span>所有函数执行（init函数除外）将通过内部参数列表，由非<code>void</code>迭代值<code>(v...)</code> （按子句顺序），然后循环输入<code>(a...)</code> （以参数顺序）组成。</span> </li> 
              <li> <span>然后按照子句顺序（pred before pred）执行step和pred函数，直到pred函数返回<code>false</code> 。</span> </li> 
              <li> <span>来自步骤函数调用的非<code>void</code>结果用于更新循环变量序列<code>(v...)</code>中的相应值。</span> <span>所有后续的函数调用都会立即显示已更新的值。</span> </li> 
              <li> <span>如果pred函数返回<code>false</code> ，则调用相应的fini函数，并从循环返回结果值（类型为<code>R</code> ）。</span> </li> 
              <li> <span>如果所有的pred函数总是返回true，那么没有调用fini函数，除了抛出异常，循环不能退出。</span> </li> 
             </ol> 
             <p> <span><em>使用提示。</em></span> </p> 
             <ul> 
              <li> <span>虽然每个step函数都将接收<em>所有</em>循环变量的当前值，但有时一个step函数只需要观察自己变量的当前值。</span> <span>在这种情况下，步骤功能可能需要明确地<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">drop all preceding loop variables</a> 。</span> <span>这将需要提及它们的类型，像<code>dropArguments(step, 0, V0.class, ...)</code>这样的表达式。</span> </li> 
              <li> <span>循环变量不需要变化;</span> <span>它们可以是循环不变的。</span> <span>一个子句可以通过没有step，pred或者fini函数的合适的init函数创建一个不变的循环。</span> <span>将传入的循环参数“连接”到相邻循环变量的step或pred函数中可能很有用。</span> </li> 
              <li> <span>如果一些子句函数是实例上的虚拟方法，则实例本身可以方便地放置在初始不变循环“variable”中，使用初始条款，如<code>new MethodHandle[]{identity(ObjType.class)}</code> 。</span> <span>在这种情况下，实例引用将是第一个迭代变量值，它将很容易使用虚方法作为子句部分，因为它们都将采用匹配该值的引导式实例引用。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>如上所述， <code>V</code>和<code>v</code>表示循环变量的类型和值;</span> <span><code>A</code>和<code>a</code>表示传递给整个循环的参数;</span> <span>而<code>R</code>是所有终结器以及结果循环的常见结果类型。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V... init...(A...);
 boolean pred...(V..., A...);
 V... step...(V..., A...);
 R fini...(V..., A...);
 R loop(A... a) {
   V... v... = init...(a...);
   for (;;) {
     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
       v = s(v..., a...);
       if (!p(v..., a...)) {
         return f(v..., a...);
       }
     }
   }
 }
 </code></pre></span> 
             </blockquote> 
             <span>请注意，参数类型列表<code>(V...)</code>和<code>(A...)</code>已经扩展到其全长，即使各个子句功能可能忽略将其全部占用。</span> 
             <span>如上所述，缺少的参数被填充，如同<a href="../../../java/lang/invoke/MethodHandles.html#dropArgumentsToMatch-java.lang.invoke.MethodHandle-int-java.util.List-int-boolean-"><code>dropArgumentsToMatch(java.lang.invoke.MethodHandle, int, java.util.List&lt;java.lang.Class&lt;?&gt;&gt;, int, boolean)</code>一样</a> 。</span> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // iterative implementation of the factorial function as a loop handle
 static int one(int k) { return 1; }
 static int inc(int i, int acc, int k) { return i + 1; }
 static int mult(int i, int acc, int k) { return i * acc; }
 static boolean pred(int i, int acc, int k) { return i &lt; k; }
 static int fin(int i, int acc, int k) { return acc; }
 // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
 assertEquals(120, loop.invoke(5));
 </code></pre></span> 
              </blockquote> 
              <span>同样的例子，放弃参数并使用组合器：</span> 
              <blockquote> 
               <span><pre><code>
 // simplified implementation of the factorial function as a loop handle
 static int inc(int i) { return i + 1; } // drop acc, k
 static int mult(int i, int acc) { return i * acc; } //drop k
 static boolean cmp(int i, int k) { return i &lt; k; }
 // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle MH_one = MethodHandles.constant(int.class, 1);
 MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc
 MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
 assertEquals(720, loop.invoke(6));
 </code></pre></span> 
              </blockquote> 
              <span>一个类似的例子，使用一个帮助对象来保存一个循环参数：</span> 
              <blockquote> 
               <span><pre><code>
 // instance-based implementation of the factorial function as a loop handle
 static class FacLoop {
   final int k;
   FacLoop(int k) { this.k = k; }
   int inc(int i) { return i + 1; }
   int mult(int i, int acc) { return i * acc; }
   boolean pred(int i) { return i &lt; k; }
   int fin(int i, int acc) { return acc; }
 }
 // assume MH_FacLoop is a handle to the constructor
 // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
 // null initializer for counter, should initialize to 0
 MethodHandle MH_one = MethodHandles.constant(int.class, 1);
 MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};
 MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
 MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
 MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);
 assertEquals(5040, loop.invoke(7));
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>clauses</code> - 符合上述规则的<a href="../../../java/lang/invoke/MethodHandle.html" title="class java.lang.invoke"><code>MethodHandle</code></a>的阵列阵列（4元组）。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个体现循环行为的方法句柄，由参数定义。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 在上述任何约束被违反的情况下。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#whileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>whileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#doWhileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>doWhileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#iteratedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>iteratedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="whileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>whileLoop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;whileLoop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                     <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred,
                                     <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>从初始化器，身体和谓词构造一个<code>while</code>循环。</span> 
             <span>这是<a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">generic loop combinator</a>的便利包装。</span> 
             <p> <span><code>pred</code>句柄描述了循环条件;</span> <span>和<code>body</code> ，它的身体。</span> <span>由此方法产生的循环将在每次迭代中首先评估谓词，然后执行其主体（如果谓词计算为<code>true</code> ）。</span> <span>一旦谓词计算为<code>false</code> （在这种情况下将不执行正文），循环将终止。</span> </p> 
             <p> <span><code>init</code>句柄描述了附加可选循环局部变量的初始值。</span> <span>在每次迭代中，此循环局部变量（如果存在）将被传递给<code>body</code>并使用从其调用返回的值进行更新。</span> <span>循环执行的结果将是附加循环局部变量（如果存在）的最终值。</span> </p> 
             <p> <span>以下规则适用于这些参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>手柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将写入<code>(V A...)V</code> ，理解是<code>void</code>类型的<code>V</code>从参数列表中<code>V</code>地删除，留下<code>(A...)V</code> 。</span> </li> 
              <li> <span>身体的参数列表<code>(V A...)</code>称为<em>内部参数列表</em> 。</span> <span>它将限制其他循环部件的参数列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>V</code> ，则生成的较短列表<code>(A...)</code>被称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>身体返回类型<code>V</code> ，如果<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>身体必须同时接受并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，它必须具有返回类型<code>V</code> 。</span> <span>其参数表（一些<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须是<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>为<code>null</code> ，则循环变量将初始化为其<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span><code>pred</code>手柄不能是<code>null</code> 。</span> <span>它必须具有<code>boolean</code>作为其返回类型。</span> <span>其参数列表（空或格式为<code>(V A*)</code> ）必须与内部参数列表完全相同。</span> </li> 
             </ul> 
             <p> <span>结果循环句柄的结果类型和参数签名如下确定：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是身体的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是类型<code>(A...)</code> ，来自外部参数列表。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示唯一循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A</code> / <code>a</code> ，该参数传递给循环。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V init(A...);
 boolean pred(V, A...);
 V body(V, A...);
 V whileLoop(A... a...) {
   V v = init(a...);
   while (pred(v, a...)) {
     v = body(v, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // implement the zip function for lists as a loop handle
 static List&lt;String&gt; initZip(Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return new ArrayList&lt;&gt;(); }
 static boolean zipPred(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return a.hasNext() &amp;&amp; b.hasNext(); }
 static List&lt;String&gt; zipStep(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) {
   zip.add(a.next());
   zip.add(b.next());
   return zip;
 }
 // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
 MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
 List&lt;String&gt; a = Arrays.asList("a", "b", "c", "d");
 List&lt;String&gt; b = Arrays.asList("e", "f", "g", "h");
 List&lt;String&gt; zipped = Arrays.asList("a", "e", "b", "f", "c", "g", "d", "h");
 assertEquals(zipped, (List&lt;String&gt;) loop.invoke(a.iterator(), b.iterator()));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，这种方法的实现可以表达如下：</span> </p> 
              <blockquote> 
               <span><pre><code>
 MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
     MethodHandle fini = (body.type().returnType() == void.class
                         ? null : identity(body.type().returnType()));
     MethodHandle[]
         checkExit = { null, null, pred, fini },
         varBody   = { init, body };
     return loop(checkExit, varBody);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>init</code> - 可选的初始化程序，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，意味着默认的初始值。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>pred</code> - 循环的条件，可能不是<code>null</code> 。</span> 
              <span>其结果类型必须为<code>boolean</code> 。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制循环参数和结果类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               实现由参数描述的 
              <code>while</code>循环的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的规则被违反。 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>pred</code>或 
              <code>body</code>是 
              <code>null</code> 。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-"><code>loop(MethodHandle[][])</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#doWhileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>doWhileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="doWhileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>doWhileLoop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;doWhileLoop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;pred)</pre> 
            <div class="block"> 
             <span>从初始化器，身体和谓词构造一个<code>do-while</code>循环。</span> 
             <span>这是<a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">generic loop combinator</a>的便利包装。</span> 
             <p> <span><code>pred</code>句柄描述了循环条件;</span> <span>和<code>body</code> ，它的身体。</span> <span>由此方法产生的循环将在每次迭代中首先执行其身体，然后评估谓词。</span> <span>一旦执行身体后，谓词计算为<code>false</code> ，循环将终止。</span> </p> 
             <p> <span><code>init</code>句柄描述了附加可选循环局部变量的初始值。</span> <span>在每次迭代中，此循环局部变量（如果存在）将被传递给<code>body</code>并使用从其调用返回的值进行更新。</span> <span>循环执行的结果将是附加循环局部变量（如果存在）的最终值。</span> </p> 
             <p> <span>以下规则适用于这些参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>手柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将写入<code>(V A...)V</code> ，理解是<code>void</code>类型<code>V</code>从参数列表中<code>V</code>地删除，留下<code>(A...)V</code> ））</span> </li> 
              <li> <span>身体的参数列表<code>(V A...)</code>称为<em>内部参数列表</em> 。</span> <span>它将限制其他循环部件的参数列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>V</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>身体返回类型<code>V</code> ，如果<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>身体必须同时接受并返回此类型的值<code>V</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（约<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a> ，外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>是<code>null</code> ，则循环变量将被初始化为其<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span><code>pred</code>手柄不能是<code>null</code> 。</span> <span>它必须有<code>boolean</code>作为其返回类型。</span> <span>其参数列表（空白或格式为<code>(V A*)</code> ）必须与内部参数列表完全相同。</span> </li> 
             </ul> 
             <p> <span>结果循环句柄的结果类型和参数签名如下确定：</span> </p> 
             <ul> 
              <li> <span>循环句柄的结果类型是身体的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是类型<code>(A...)</code> ，来自外部参数列表。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示唯一循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A</code> / <code>a</code> ，该参数传递给循环。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V init(A...);
 boolean pred(V, A...);
 V body(V, A...);
 V doWhileLoop(A... a...) {
   V v = init(a...);
   do {
     v = body(v, a...);
   } while (pred(v, a...));
   return v;
 }
 </code></pre></span> 
             </blockquote> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // int i = 0; while (i &lt; limit) { ++i; } return i; =&gt; limit
 static int zero(int limit) { return 0; }
 static int step(int i, int limit) { return i + 1; }
 static boolean pred(int i, int limit) { return i &lt; limit; }
 // assume MH_zero, MH_step, and MH_pred are handles to the above methods
 MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
 assertEquals(23, loop.invoke(23));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，这种方法的实现可以表达如下：</span> </p> 
              <blockquote> 
               <span><pre><code>
 MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
     MethodHandle fini = (body.type().returnType() == void.class
                         ? null : identity(body.type().returnType()));
     MethodHandle[] clause = { init, body, pred, fini };
     return loop(clause);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>init</code> - 可选的初始化程序，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，意味着默认的初始值。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它控制循环参数和结果类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>pred</code> - 循环的条件，可能不是<code>null</code> 。</span> 
              <span>其结果类型必须为<code>boolean</code> 。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               实现 
              <code>while</code>循环的方法句柄，如参数所述。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果参数的规则被违反。 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>pred</code>或 
              <code>body</code>是 
              <code>null</code> 。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-"><code>loop(MethodHandle[][])</code></a> ， 
              <a href="../../../java/lang/invoke/MethodHandles.html#whileLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>whileLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>countedLoop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;countedLoop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterations,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个运行给定次数迭代的循环。</span> 
             <span>这是一个方便的包装器<a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">generic loop combinator</a> 。</span> 
             <p> <span>迭代次数由<code>iterations</code>句柄评估结果确定。</span> <span>循环计数器<code>i</code>的类型是一个额外的循环迭代变量<code>int</code> 。</span> <span>它将被初始化为0，并在每次迭代中递增1。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回非<code>void</code>类型的<code>V</code> ，则该类型的前导循环迭代变量也存在。</span> <span>这个变量是使用初始化的可选<code>init</code>手柄，或到<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a>类型的<code>V</code>如果该句柄是<code>null</code> 。</span> </p> 
             <p> <span>在每次迭代中，迭代变量被传递给<code>body</code>句柄的调用。</span> <span>从主体（类型<code>V</code> ）返回的非<code>void</code>值更新前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>iterations</code>句柄不能为<code>null</code> ，必须返回<code>int</code> ，参考类型列表中的<code>I</code> 。</span> </li> 
              <li> <span><code>body</code>句柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V I A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(I A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将写<code>(V I A...)V</code> ，理解是<code>void</code>类型<code>V</code>从参数列表中<code>V</code>地删除，留下<code>(I A...)V</code> ）</span> </li> 
              <li> <span>身体的参数列表<code>(V I A...)</code>对称为<em>内部参数列表</em>的类型列表做出贡献。</span> <span>它将限制其他循环部件的参数列表。</span> </li> 
              <li> <span>作为一种特殊情况，如果机构仅提供<code>V</code>和<code>I</code>类型，则不附加<code>A</code>类型，则内部参数列表将通过<code>iterations</code>句柄的参数类型<code>A...</code>进行<code>iterations</code> 。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>(V I)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>身体返回类型<code>V</code> ，如果<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>身体必须同时接受一个前导参数，并返回一个<code>V</code>类型的值。</span> </li> 
              <li> <span>如果<code>init</code>非<code>null</code> ，它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（约<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须是<a href="MethodHandles.html#effid">effectively identical</a> ，外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>为<code>null</code> ，则循环变量将初始化为其<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span><code>iterations</code> （某种形式为<code>(A*)</code> ）的参数表必须与外部参数表<code>(A...)</code>有效相同。</span> </li> 
             </ul> 
             <p> <span>结果循环句柄的结果类型和参数签名如下确定：</span> </p> 
             <ul> 
              <li> <span>循环手柄的结果类型是身体的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是类型<code>(A...)</code> ，来自外部参数列表。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示第二个循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A...</code> / <code>a...</code>代表传递给循环论证。</span> </p> 
             <blockquote> 
              <span><pre><code>
 int iterations(A...);
 V init(A...);
 V body(V, int, A...);
 V countedLoop(A... a...) {
   int end = iterations(a...);
   V v = init(a...);
   for (int i = 0; i &lt; end; ++i) {
     v = body(v, i, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>具有完全符合身体方法的示例：</span> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!"; for (int i = 0; i &lt; 13; ++i) { s = "na " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, String init) { return "na " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle fit13 = MethodHandles.constant(int.class, 13);
 MethodHandle start = MethodHandles.identity(String.class);
 MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke("Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，使用最简单的body方法类型的示例，并将迭代次数传递给循环调用：</span> </p> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!"; for (int i = 0; i &lt; 13; ++i) { s = "na " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter ) { return "na " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);
 MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);
 MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -&gt; "na " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke(13, "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，将迭代次数，要追加的字符串和字符串作为循环参数附加的示例：</span> </p> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!", t = "na"; for (int i = 0; i &lt; 13; ++i) { s = t + " " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + " " + v; }
 // assume MH_step is a handle to the method above
 MethodHandle count = MethodHandles.identity(int.class);
 MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);
 MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -&gt; pre + " " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke(13, "na", "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，示例说明了使用<a href="../../../java/lang/invoke/MethodHandles.html#dropArgumentsToMatch-java.lang.invoke.MethodHandle-int-java.util.List-int-"><code>dropArgumentsToMatch(MethodHandle, int, List, int)</code></a>强制循环类型的示例：</span> </p> 
              <blockquote> 
               <span><pre><code>
 // String s = "Lambdaman!", t = "na"; for (int i = 0; i &lt; 13; ++i) { s = t + " " + s; } return s;
 // =&gt; a variation on a well known theme
 static String step(String v, int counter, String pre) { return pre + " " + v; }
 // assume MH_step is a handle to the method above
 MethodType loopType = methodType(String.class, String.class, int.class, String.class);
 MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);
 MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);
 MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);
 MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -&gt; pre + " " + v
 assertEquals("na na na na na na na na na na na na na Lambdaman!", loop.invoke("na", 13, "Lambdaman!"));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，这种方法的实现可以表达如下：</span> </p> 
              <blockquote> 
               <span><pre><code>
 MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
     return countedLoop(empty(iterations.type()), iterations, init, body);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>iterations</code> - 一个非<code>null</code>句柄，用于返回此循环应运行的迭代次数。</span> 
              <span>手柄的结果类型必须是<code>int</code> 。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始化程序，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，意味着默认的初始值。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它在标准情况下控制循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果非空）加上一个<code>int</code>参数（对于计数器），并且可以接受任何数量的附加类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示循环的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>iterations</code>或 
              <code>body</code>句柄中的任何一个是 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果有任何论据违反上述规则。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>countedLoop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;countedLoop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;start,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;end,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                       <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个计数一系列数字的循环。</span> 
             <span>这是一个方便的包装器<a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">generic loop combinator</a> 。</span> 
             <p> <span>循环计数器<code>i</code>是类型为<code>int</code>的循环迭代变量。</span> <span><code>start</code>和<code>end</code>句柄确定循环计数器的起始（包括）和结束（排除）值。</span> <span>循环计数器将初始化为从<code>start</code>句柄的评估返回的<code>int</code>值，并运行到步长为1的<code>end</code> （排他）返回的值。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回非<code>void</code>类型的<code>V</code> ，则该类型的前导循环迭代变量也存在。</span> <span>这个变量是使用初始化的可选<code>init</code>手柄，或到<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a>类型的<code>V</code>如果该句柄是<code>null</code> 。</span> </p> 
             <p> <span>在每次迭代中，迭代变量被传递到调用<code>body</code>句柄。</span> <span>从主体（类型为<code>V</code> ）返回的非<code>void</code>值更新了前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>start</code>和<code>end</code>句柄不能是<code>null</code> ，并且必须都返回公共类型<code>int</code> ，在这里称为参数类型列表中的<code>I</code> 。</span> </li> 
              <li> <span><code>body</code>手柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V I A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(I A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将类型<code>void</code>分配给名称<code>V</code> ，我们将写<code>(V I A...)V</code> ，理解是<code>void</code>类型<code>V</code>从参数列表中<code>V</code>地删除，留下<code>(I A...)V</code> ）</span> </li> 
              <li> <span>身体的参数列表<code>(V I A...)</code>有助于称为<em>内部参数列表</em>的类型的<em>列表</em> 。</span> <span>它将限制其他循环部件的参数列表。</span> </li> 
              <li> <span>作为一种特殊情况，如果机构仅提供<code>V</code>和<code>I</code>类型，而不附加<code>A</code>类型，则内部参数列表将通过<code>end</code>句柄的参数类型<code>A...</code>进行<code>end</code> 。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>(V I)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>身体返回类型<code>V</code> ，如果非<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>主体必须同时接受一个前导参数，并返回一个<code>V</code>类型的值。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，它必须具有返回类型<code>V</code> 。</span> <span>其参数表（一些<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须是<a href="MethodHandles.html#effid">effectively identical</a>到外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>为<code>null</code> ，则循环变量将被初始化为其<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span><code>start</code> （某种形式为<code>(A*)</code> ）的参数表必须与外部参数表<code>(A...)</code>有效地相同。</span> </li> 
              <li> <span>同样， <code>end</code>的参数表必须与外部参数列表有效地相同。</span> </li> 
             </ul> 
             <p> <span>结果循环句柄的结果类型和参数签名如下确定：</span> </p> 
             <ul> 
              <li> <span>循环手柄的结果类型是身体的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是类型<code>(A...)</code> ，来自外部参数列表。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示第二个循环变量的类型/值以及循环的结果类型;</span> <span>和<code>A...</code> / <code>a...</code>代表传递给循环论证。</span> </p> 
             <blockquote> 
              <span><pre><code>
 int start(A...);
 int end(A...);
 V init(A...);
 V body(V, int, A...);
 V countedLoop(A... a...) {
   int e = end(a...);
   int s = start(a...);
   V v = init(a...);
   for (int i = s; i &lt; e; ++i) {
     v = body(v, i, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>该方法的实现可以表达如下：</span> 
              <blockquote> 
               <span><pre><code>
 MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
     // assume MH_increment and MH_predicate are handles to implementation-internal methods with
     // the following semantics:
     // MH_increment: (int limit, int counter) -&gt; counter + 1
     // MH_predicate: (int limit, int counter) -&gt; counter &lt; limit
     Class&lt;?&gt; counterType = start.type().returnType();  // int
     Class&lt;?&gt; returnType = body.type().returnType();
     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;
     if (returnType != void.class) {  // ignore the V variable
         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
         pred = dropArguments(pred, 1, returnType);  // ditto
         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit
     }
     body = dropArguments(body, 0, counterType);  // ignore the limit variable
     MethodHandle[]
         loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
         bodyClause = { init, body },            // v = init(); v = body(v, i)
         indexVar   = { start, incr };           // i = start(); i = i + 1
     return loop(loopLimit, bodyClause, indexVar);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>start</code> - 一个非<code>null</code>句柄返回循环计数器的<code>int</code> ，它必须是<code>int</code> 。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>end</code> - 一个非<code>null</code>句柄来返回循环计数器的结束值（循环将运行到<code>end-1</code> ）。</span> 
              <span>结果类型必须是<code>int</code> 。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始化程序，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，意味着默认的初始值。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它在标准情况下控制循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果是非<code>int</code> ）加上一个<code>int</code>参数（对于计数器），并且可以接受任何数量的附加类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               表示循环的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任何的 
              <code>start</code> ， 
              <code>end</code> ，或 
              <code>body</code>手柄为 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果有任何争议违反上述规则。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#countedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>countedLoop(MethodHandle, MethodHandle, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> <a id="iteratedLoop-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockList"> 
           <li class="blockList"> <h4>iteratedLoop</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iteratedLoop​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;iterator,
                                        <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;init,
                                        <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;body)</pre> 
            <div class="block"> 
             <span>构造一个范围超过由<code>Iterator&lt;T&gt;</code>生成的值的<code>Iterator&lt;T&gt;</code> 。</span> 
             <span>这是<a href="../../../java/lang/invoke/MethodHandles.html#loop-java.lang.invoke.MethodHandle:A...-">generic loop combinator</a>的便利包装。</span> 
             <p> <span>迭代器本身将由<code>iterator</code>句柄的评估来确定。</span> <span>它产生的每个值都将存储在类型为<code>T</code>的循环迭代变量中。</span> </p> 
             <p> <span>如果<code>body</code>句柄返回一个非<code>void</code>类型的<code>V</code> ，则该类型的前导循环迭代变量也存在。</span> <span>该变量使用可选的<code>init</code>句柄进行初始化，或<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">V</a>的<code>V</code>如果该句柄为<code>null</code> 。</span> </p> 
             <p> <span>在每次迭代中，迭代变量被传递到调用<code>body</code>句柄。</span> <span>从主体（类型<code>V</code> ）返回的非<code>void</code>值更新前导迭代变量。</span> <span>环形手柄执行的结果将是最终<code>V</code>该变量的值（或<code>void</code>如果没有<code>V</code>变量）。</span> </p> 
             <p> <span>以下规则适用于参数句柄：</span> </p> 
             <ul> 
              <li> <span><code>body</code>手柄不能是<code>null</code> ;</span> <span>其类型必须为<code>(V T A...)V</code> ，其中<code>V</code>为非<code>void</code> ，否则为<code>(T A...)void</code> 。</span> <span>（在<code>void</code>情况下，我们将<code>void</code>的类型分配给<code>V</code> ，我们将写入<code>(V T A...)V</code> ，理解是<code>void</code>类型的<code>V</code>从参数列表中<code>(T A...)V</code> ，留下<code>(T A...)V</code> 。</span> </li> 
              <li> <span>身体的参数列表<code>(V T A...)</code>对称为<em>内部参数列表</em>的类型的列表做出贡献。</span> <span>它将限制其他循环部件的参数列表。</span> </li> 
              <li> <span>作为一种特殊情况，如果机构仅提供<code>V</code>和<code>T</code>类型，不附加<code>A</code>类型，则内部参数列表将通过<code>iterator</code>句柄的参数类型<code>A...</code>进行<code>iterator</code> ;</span> <span>如果是<code>null</code> ，添加单个类型<code>Iterable</code> ，构成<code>A...</code>列表。</span> </li> 
              <li> <span>如果从内部参数列表中删除迭代变量类型<code>(V T)</code> ，则生成的较短列表<code>(A...)</code>称为<em>外部参数列表</em> 。</span> </li> 
              <li> <span>身体返回类型<code>V</code> ，如果<code>void</code> ，则确定循环的附加状态变量的类型。</span> <span>主体必须同时接受一个前导参数，并返回一个<code>V</code>类型的值。</span> </li> 
              <li> <span>如果<code>init</code>是非<code>null</code> ，它必须具有返回类型<code>V</code> 。</span> <span>其参数列表（约<a href="MethodHandles.html#astar">form <code>(A*)</code></a> ）必须为<a href="MethodHandles.html#effid">effectively identical</a> ，外部参数列表为<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>init</code>为<code>null</code> ，则循环变量将初始化为其<a href="../../../java/lang/invoke/MethodHandles.html#empty-java.lang.invoke.MethodType-">default value</a> 。</span> </li> 
              <li> <span>如果<code>iterator</code>句柄为非<code>null</code> ，则必须具有返回类型<code>java.util.Iterator</code>或其子类型。</span> <span>执行循环时产生的迭代器将被假定为产生可转换为类型<code>T</code> 。</span> </li> 
              <li> <span>一个的参数列表<code>iterator</code>即非<code>null</code> （的某种形式的<code>(A*)</code> ）必须有效地等同于外部参数列表<code>(A...)</code> 。</span> </li> 
              <li> <span>如果<code>iterator</code>为<code>null</code>则默认为方法句柄，其行为类似于<a href="../../../java/lang/Iterable.html#iterator--"><code>Iterable.iterator()</code></a> 。</span> <span>在这种情况下，内部参数表<code>(V T A...)</code>必须至少有一个<code>A</code>类型，并且默认的迭代器句柄参数被调整为接受前导的<code>A</code>类型，好像通过<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>转换方法。</span> <span>领先的<code>A</code>类型必须是<code>Iterable</code>或其子类型。</span> <span>这个转换步骤，在循环施工时完成，不能抛出一个<code>WrongMethodTypeException</code> 。</span> </li> 
             </ul> 
             <p> <span>类型<code>T</code>可以是原语或参考。</span> <span>由于类型<code>Iterator&lt;T&gt;</code>在该方法手柄表示被擦除到原始类型<code>Iterator</code> ，所述<code>iteratedLoop</code>组合子调整为主导参数类型<code>body</code>到<code>Object</code>仿佛由<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>转换方法。</span> <span>因此，如果循环执行时出现错误类型的迭代器，则可能会由于<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType(MethodType)</code></a>执行的动态转换而导致运行时异常。</span> </p> 
             <p> <span>结果循环句柄的结果类型和参数签名如下确定：</span> </p> 
             <ul> 
              <li> <span>循环手柄的结果类型是身体的结果类型<code>V</code> 。</span> </li> 
              <li> <span>循环句柄的参数类型是类型<code>(A...)</code> ，来自外部参数列表。</span> </li> 
             </ul> 
             <p> <span>这里是生成的循环句柄的伪代码。</span> <span>在代码中， <code>V</code> / <code>v</code>表示循环变量的类型/值以及循环的结果类型;</span> <span><code>T</code> / <code>t</code> ，该结构的循环迭代的元素，和<code>A...</code> / <code>a...</code>表示传递给循环参数。</span> </p> 
             <blockquote> 
              <span><pre><code>
 Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
 V init(A...);
 V body(V,T,A...);
 V iteratedLoop(A... a...) {
   Iterator&lt;T&gt; it = iterator(a...);
   V v = init(a...);
   while (it.hasNext()) {
     T t = it.next();
     v = body(v, t, a...);
   }
   return v;
 }
 </code></pre></span> 
             </blockquote> 
             <p></p> 
            </div> 
            <dl> 
             <dt> 
              <span class="simpleTagLabel">API Note:</span> 
             </dt> 
             <dd> 
              <span>例：</span> 
              <blockquote> 
               <span><pre><code>
 // get an iterator from a list
 static List&lt;String&gt; reverseStep(List&lt;String&gt; r, String e) {
   r.add(0, e);
   return r;
 }
 static List&lt;String&gt; newArrayList() { return new ArrayList&lt;&gt;(); }
 // assume MH_reverseStep and MH_newArrayList are handles to the above methods
 MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
 List&lt;String&gt; list = Arrays.asList("a", "b", "c", "d", "e");
 List&lt;String&gt; reversedList = Arrays.asList("e", "d", "c", "b", "a");
 assertEquals(reversedList, (List&lt;String&gt;) loop.invoke(list));
 </code></pre></span> 
              </blockquote> 
              <p> <span>，该方法的实现可以大致表示如下：</span> </p> 
              <blockquote> 
               <span><pre><code>
 MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable
     Class&lt;?&gt; returnType = body.type().returnType();
     Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
     MethodHandle retv = null, step = body, startIter = iterator;
     if (returnType != void.class) {
         // the simple thing first:  in (I V A...), drop the I to get V
         retv = dropArguments(identity(returnType), 0, Iterator.class);
         // body type signature (V T A...), internal loop types (I V A...)
         step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
     }
     if (startIter == null)  startIter = MH_getIter;
     MethodHandle[]
         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())
         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)
     return loop(iterVar, bodyClause);
 }
 </code></pre></span> 
              </blockquote> 
             </dd> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <span><code>iterator</code> - 返回迭代器启动循环的可选句柄。</span> 
              <span>如果非<code>null</code> ，手柄必须返回<a href="../../../java/util/Iterator.html" title="java.util中的接口"><code>Iterator</code></a>或一个子类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>init</code> - 可选的初始化器，提供循环变量的初始值。</span> 
              <span>可能是<code>null</code> ，暗示默认的初始值。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dd> 
              <span><code>body</code> - 循环体，可能不是<code>null</code> 。</span> 
              <span>它在标准情况下控制循环参数和结果类型（详见上文）。</span> 
              <span>它必须接受自己的返回类型（如果是非<code>T</code> ）加上一个<code>T</code>参数（对于迭代值），并且可以接受任何数量的其他类型。</span> 
              <span>见上文其他约束。</span> 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               体现迭代循环功能的方法句柄。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果 
              <code>body</code>句柄是 
              <code>null</code> 。 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果任何参数违反上述要求。 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
            </dl> </li> 
          </ul> <a id="tryFinally-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
           <!--   --> </a> 
          <ul class="blockListLast"> 
           <li class="blockList"> <h4>tryFinally</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;tryFinally​(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                      <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;cleanup)</pre> 
            <div class="block"> 
             <span>创建一个方法句柄，通过将其包装在一个<code>try-finally</code>块中来适应<code>target</code>方法句柄。</span> 
             <span>另一个方法手柄， <code>cleanup</code> ，代表<code>finally</code>块的功能。</span> 
             <span>在执行<code>target</code>句柄期间抛出的任何异常都将传递给<code>cleanup</code>句柄。</span> 
             <span>除非<code>cleanup</code>处理会引发异常，否则将被<code>cleanup</code>抛出异常。</span> 
             <span>从返回的值<code>cleanup</code>手柄的执行将是执行的结果<code>try-finally</code>手柄。</span> 
             <p> <span><code>cleanup</code>句柄将被传递一个或两个额外的前导参数。</span> <span>第一个是在执行<code>target</code>句柄期间抛出的异常，或者如果没有抛出异常， <code>null</code> 。</span> <span>第二个是执行<code>target</code>句柄的结果，或者如果它引发异常，则需要一个<code>null</code>或<code>false</code>所需类型的值作为占位符。</span> <span>如果<code>target</code>句柄具有<code>void</code>返回类型，则第二个参数不存在。</span> <span>（需要注意的是，除了参数类型转换，组合子表示<code>void</code>通过省略相应的自相矛盾的论点，而不是通过插入在参数列表值<code>null</code>或零值）。</span> </p> 
             <p> <span><code>target</code>和<code>cleanup</code>句柄必须具有相同的对应参数和返回类型，不同之处在于<code>cleanup</code>句柄可以省略尾随参数。</span> <span>此外， <code>cleanup</code>句柄必须有一个或两个额外的前导参数：</span> </p> 
             <ul> 
              <li> <span>一个<code>Throwable</code> ，它将携带由<code>target</code>句柄（如果有的话）抛出的异常;</span> <span>和</span> </li> 
              <li> <span>与<code>target</code>和<code>cleanup</code>的返回类型相同类型的参数，其将携带执行<code>target</code>句柄的结果。</span> <span>如果<code>target</code>返回<code>void</code> ，则此参数不存在。</span> </li> 
             </ul> 
             <p> <span>生成的适配器的伪代码如下。</span> <span>在代码中， <code>V</code>代表<code>try/finally</code>结构的结果类型;</span> <span><code>A</code> / <code>a</code> ，类型和参数，以由所述的清理消耗所得句柄值;</span> <span>和<code>B</code> ，那些通过清理<code>b</code>的结果句柄的参数。</span> </p> 
             <blockquote> 
              <span><pre><code>
 V target(A..., B...);
 V cleanup(Throwable, V, A...);
 V adapter(A... a, B... b) {
   V result = (zero value for V);
   Throwable throwable = null;
   try {
     result = target(a..., b...);
   } catch (Throwable t) {
     throwable = t;
     throw t;
   } finally {
     result = cleanup(throwable, result, a...);
   }
   return result;
 }
 </code></pre></span> 
             </blockquote> 
             <p> <span>请注意，保存的参数（伪代码中的<code>a...</code> ）无法通过执行目标进行修改，如果调用该引用，参数将从调用程序不<code>a...</code>改为清理。</span> </p> 
             <p> <span>目标和清理必须返回相同的类型，即使清理总是抛出。</span> <span>要创建这样一个抛出的清理，使用<a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-"><code>throwException</code>编写</a>清理逻辑，以创建正确返回类型的方法句柄。</span> </p> 
             <p> <span>请注意， <code>tryFinally</code>不会将异常转换为正常返回。</span> <span>在极少数情况下，必须以这种方式转换异常，首先用<a href="../../../java/lang/invoke/MethodHandles.html#catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-"><code>catchException(MethodHandle, Class, MethodHandle)</code></a>包装目标以捕获传出的异常，然后用<code>tryFinally</code>包装。</span> </p> 
            </div> 
            <dl> 
             <dt> 
              <span class="paramLabel">参数</span> 
             </dt> 
             <dd> 
              <code>target</code> - 其执行将包装在一个 
              <code>try</code>块中的 
              <code>try</code> 。 
             </dd> 
             <dd> 
              <code>cleanup</code> - finally块中调用的句柄。 
             </dd> 
             <dt> 
              <span class="returnLabel">结果</span> 
             </dt> 
             <dd>
               一个体现 
              <code>try-finally</code>块的方法句柄由两个参数组成。 
             </dd> 
             <dt> 
              <span class="throwsLabel">异常</span> 
             </dt> 
             <dd> 
              <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - 如果任何参数为空 
             </dd> 
             <dd> 
              <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - 如果 
              <code>cleanup</code>不接受所需的前导参数，或者方法句柄类型在其返回类型及其对应的尾随参数中不匹配 
             </dd> 
             <dt> 
              <span class="simpleTagLabel">从以下版本开始：</span> 
             </dt> 
             <dd>
               9 
             </dd> 
             <dt> 
              <span class="seeLabel">另请参见：</span> 
             </dt> 
             <dd> 
              <a href="../../../java/lang/invoke/MethodHandles.html#catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-"><code>catchException(MethodHandle, Class, MethodHandle)</code></a> 
             </dd> 
            </dl> </li> 
          </ul> </li> 
        </ul> 
       </section> </li> 
     </ul> 
    </div> 
   </div> 
  </main> 
  <!-- ========= END OF CLASS DATA ========= --> 
  <footer role="contentinfo"> 
   <nav role="navigation"> 
    <!-- ======= START OF BOTTOM NAVBAR ====== --> 
    <div class="bottomNav"> 
     <a id="navbar.bottom"> 
      <!--   --> </a> 
     <div class="skipNav"> 
      <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
     </div> 
     <a id="navbar.bottom.firstrow"> 
      <!--   --> </a> 
     <ul class="navList" title="Navigation"> 
      <li><a href="../../../overview-summary.html">概述</a></li> 
      <li><a href="../../../java.base-summary.html">Module</a></li> 
      <li><a href="package-summary.html">软件包</a></li> 
      <li class="navBarCell1Rev">Class</li> 
      <li><a href="class-use/MethodHandles.html">使用</a></li> 
      <li><a href="package-tree.html">树</a></li> 
      <li><a href="../../../deprecated-list.html">已过时的</a></li> 
      <li><a href="../../../index-files/index-1.html">索引</a></li> 
      <li><a href="../../../help-doc.html">帮助</a></li> 
     </ul> 
     <div class="aboutLanguage"> 
      <div style="margin-top: 14px;"> 
       <strong>Java SE 9 &amp; JDK 9</strong> 
      </div> 
     </div> 
    </div> 
    <div class="subNav"> 
     <ul class="navList"> 
      <li><a href="../../../java/lang/invoke/MethodHandleProxies.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
      <li><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
     </ul> 
     <ul class="navList"> 
      <li><a href="../../../index.html?java/lang/invoke/MethodHandles.html" target="_top">框架</a></li> 
      <li><a href="MethodHandles.html" target="_top">无框架</a></li> 
     </ul> 
     <ul class="navList" id="allclasses_navbar_bottom"> 
      <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
     </ul> 
     <div> 
      <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
      <noscript> 
       <div>
         JavaScript is disabled on your browser. 
       </div> 
      </noscript> 
     </div> 
     <div> 
      <ul class="subNavList"> 
       <li>概要：&nbsp;</li> 
       <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.summary">方法</a></li> 
      </ul> 
      <ul class="subNavList"> 
       <li>详细信息：&nbsp;</li> 
       <li>字段&nbsp;|&nbsp;</li> 
       <li>构造方法&nbsp;|&nbsp;</li> 
       <li><a href="#method.detail">方法</a></li> 
      </ul> 
     </div> 
     <a id="skip.navbar.bottom"> 
      <!--   --> </a> 
    </div> 
    <!-- ======== END OF BOTTOM NAVBAR ======= --> 
   </nav> 
   <p class="legalCopy"><small><a href="http://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="http://www.oracle.com/pls/topic/lookup?ctx=javase9&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../legal/copyright.html">Copyright</a> © 1993, 2017, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java9speclicense.html">license terms</a> and the <a href="http://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. 
     <!-- Version 9+178 --></small> 
    <div id="juede_adDiv" data-docversion="179" data-translate="google" data-version="1.0.0"> 

     <div id="adDivContent">
      本帮助文档是使用
      <a href="http://translate.google.com/" target="_blank">《谷歌翻译》</a>翻译，请与英文版配合使用
      <div>
       <div></div>
      </div>
     </div>
    </div></p> 
  </footer>  
 </body>
</html>